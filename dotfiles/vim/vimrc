" Important stuff at the beginning {{{1
set nocompatible
set encoding=utf-8
let mapleader=","
let maplocalleader=",,"

let g:user_name = "Jan Larres"
let g:user_email = "jan@majutsushi.net"

if !has('nvim')
    call mkdir(expand("$XDG_STATE_HOME/vim/backup"), "p")
    call mkdir(expand("$XDG_STATE_HOME/vim/swap"), "p")
    call mkdir(expand("$XDG_STATE_HOME/vim/undo"), "p")
endif

let plugin_dir = expand('$XDG_STATE_HOME/vim/plugged')
if empty(glob(plugin_dir . '/vim-plug/autoload/plug.vim'))
    silent execute '!curl -fLo ' . plugin_dir . '/vim-plug/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
if has('vim_starting')
    let &runtimepath ..= "," .. plugin_dir .. "/vim-plug"
endif

call plug#begin(plugin_dir)

" Navigation
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'Lokaltog/vim-easymotion', {'on': '<Plug>(easymotion'}
Plug 'bruno-/vim-vertical-move', {'on': '<Plug>(vertical_move'}
Plug 'jlanzarotta/bufexplorer', {'on': 'BufExplorer'}

" Editing
Plug 'SirVer/ultisnips'
Plug 'dhruvasagar/vim-table-mode'
Plug 'junegunn/vim-easy-align', {'on': ['EasyAlign', '<Plug>(EasyAlign)']}
Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-entire'
Plug 'kana/vim-textobj-function'
Plug 'kana/vim-textobj-indent'
Plug 'kana/vim-textobj-line'
Plug 'Konfekt/FastFold'
Plug 'saihoooooooo/vim-textobj-space'
Plug 'mbbill/undotree', {'on': 'UndotreeToggle'}
Plug 'sjl/splice.vim', {'on': 'SpliceInit'}
Plug 'terryma/vim-expand-region', {'on': '<Plug>(expand_region'}
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-surround'
Plug 'terryma/vim-multiple-cursors'
Plug 'wellle/targets.vim'

" Filetypes
Plug 'preservim/vim-markdown'
Plug 'mhinz/vim-rfc'
Plug 'dense-analysis/ale'

" Information
Plug 'airblade/vim-gitgutter'
Plug 'tomtom/quickfixsigns_vim'
Plug 'ynkdir/vim-vimlparser'
Plug 'syngan/vim-vimlint'
Plug 'tpope/vim-characterize'
Plug 'luochen1990/rainbow'
Plug 'machakann/vim-highlightedyank'
Plug 'Konfekt/vim-keyword-lookup'

" Misc
Plug 'tomtom/tlib_vim'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-scriptease'
Plug 'tpope/vim-unimpaired'
Plug 'tyru/open-browser.vim'
Plug 'wsdjeg/vim-fetch'
Plug 'hzchirs/vim-material'

Plug 'jamessan/vim-gnupg'

Plug 'vim-scripts/ZoomWin'

for bundle_path in glob(expand('$XDG_CONFIG_HOME') . '/nvim/bundles/*', 0, 1)
    call plug#(bundle_path)
endfor
for bundle_path in glob('~/src/vim/bundles/*', 0, 1)
    call plug#(bundle_path)
endfor
unlet bundle_path

call plug#end()


" search for exuberant ctags
let ctagsbins  = []
let ctagsbins += [expand('~/src/ctags/uctags/ctags')]
let ctagsbins += [expand('~/src/ctags/ctags/dctags')]
let ctagsbins += ['ctags-exuberant'] " Debian
let ctagsbins += ['exuberant-ctags']
let ctagsbins += ['exctags'] " FreeBSD, NetBSD
let ctagsbins += ['/usr/local/bin/ctags'] " Homebrew
let ctagsbins += ['/opt/local/bin/ctags'] " Macports
let ctagsbins += ['ectags'] " OpenBSD
let ctagsbins += ['ctags']
let ctagsbins += ['ctags.exe']
let ctagsbins += ['tags']
let g:ctagsbin = ''
for ctags in ctagsbins
    if executable(ctags)
        let g:ctagsbin = ctags
        break
    endif
endfor
unlet ctagsbins

function s:sid() abort
    return matchstr(expand('<sfile>'), '\zs<SNR>\d\+_\zeSID$')
endfun

" Autocommands {{{1

" remove all autocommands to avoid sourcing them twice
augroup vimrc
    autocmd!
augroup END

set cursorline
autocmd vimrc InsertLeave * set cursorline
autocmd vimrc InsertEnter * set nocursorline

" Copy clipboard contents to + register when entering vim
if has("clipboard")
    autocmd VimEnter * call setreg('+', system('clipboard-paste'))
endif

autocmd vimrc StdinReadPost * set buftype=nofile

autocmd vimrc VimResized * execute "normal! \<C-w>="

" Don't screw up folds when inserting text that might affect them, until
" leaving insert mode. Foldmethod is local to the window. Protect against
" screwing up folding when switching between windows.
autocmd vimrc InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
autocmd vimrc InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

" inspired by https://github.com/kana/vim-tabpagecd
autocmd vimrc TabEnter * if exists('t:cwd') | execute 'cd ' . fnameescape(t:cwd) | endif
autocmd vimrc TabLeave * let t:cwd = getcwd()

autocmd vimrc BufNewFile,BufWritePre * call AutoMkDir()

" create undo break point
autocmd vimrc CursorHoldI * call feedkeys("\<C-G>u", "nt")

" When switching buffers, preserve window view.
function! IsNotSpecialBuf(buf) abort
    return ((&buftype != "quickfix") &&
          \ !&previewwindow &&
          \ !&scrollbind &&
          \ (bufname(a:buf) !~ "NERD_tree") &&
          \ (bufname(a:buf) !~ "__Tag_List__") &&
          \ (bufname(a:buf) !~ "__Tagbar__") &&
          \ (bufname(a:buf) !~ "fugitive*"))
endfunction
if v:version >= 700
    autocmd vimrc BufLeave * if IsNotSpecialBuf("%") | let b:winview = winsaveview() | endif
    autocmd vimrc BufEnter * if (exists('b:winview') && IsNotSpecialBuf("%")) | call winrestview(b:winview) | endif
endif

" Prevent files with very long pathnames from causing an error when writing
" the undofile
autocmd vimrc BufReadPost * if len(substitute(expand('%:p'), '/', '%', 'g')) > 255 | setlocal noundofile | endif

" automatically give executable permissions if file begins with #!
" and contains" '/bin/' in the path
" From https://github.com/mitechie/pyvim/blob/master/.vimrc
" Also check for file being readable to ignore netrw-loaded files.
autocmd vimrc BufWritePost *
    \ if getline(1) =~ "^#!" && getline(1) =~ "/bin/" && filereadable('<afile>') |
    \     execute 'silent !chmod u+x <afile>' |
    \ endif

" filetype-specific settings
augroup vimrc
    autocmd FileType asciidoc  setlocal comments=://,b:#,:%,n:>,fb:-,fb:*,fb:.
    autocmd FileType make      setlocal noexpandtab tabstop=8 shiftwidth=8 softtabstop=0
    autocmd FileType gtkrc     setlocal tabstop=2 shiftwidth=2 softtabstop=2
    autocmd FileType haskell   compiler ghc
    autocmd FileType ruby      setlocal omnifunc=rubycomplete#Complete
    autocmd FileType gitcommit setlocal textwidth=72
augroup END

augroup commentstrings
    autocmd!
    autocmd FileType asciidoc    setlocal commentstring=//%s
    autocmd FileType cfg         setlocal commentstring=#%s
    autocmd FileType cpp         setlocal commentstring=//%s
    autocmd FileType desktop     setlocal commentstring=#%s
    autocmd FileType gtkrc       setlocal commentstring=#%s
    autocmd FileType pentadactyl setlocal commentstring=\"%s
    autocmd FileType pfmain      setlocal commentstring=#%s
    autocmd FileType tmux        setlocal commentstring=#%s
augroup END

autocmd vimrc BufReadPost emacsfilevars.vim let b:emacs_ignore_file = 1

" Functions {{{1

" AutoMkDir() {{{2
" Automatically create dir to write file to if it doesn't exist
function! AutoMkDir()
    let file = expand('<afile>')
    if file =~# '^[a-z]\+:\/\/'
        " Netrw file or similar, don't try creating the directory
        return
    endif
    let required_dir = fnamemodify(file, ':p:h')
    if !isdirectory(required_dir)
        if confirm("Directory '" . required_dir . "' doesn't exist.", "&Abort\n&Create it") != 2
            bdelete
            return
        endif

        try
            call mkdir(required_dir, 'p')
        catch
            if confirm("Can't create '" . required_dir . "'", "&Abort\n&Continue anyway") != 2
                bdelete
                return
            endif
        endtry
    endif
endfunction

" Bclose() {{{2
" delete buffer without closing window
function! Bclose()
    let curbufnr = bufnr("%")
    let altbufnr = bufnr("#")

    if buflisted(altbufnr)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == curbufnr
        new
    endif

    if buflisted(curbufnr)
        execute("bdelete! " . curbufnr)
    endif
endfunction

" CenterBlock() {{{2
function! CenterBlock(...) range
    let width = a:0 > 0 ? a:1 : (&textwidth > 0 ? &textwidth : 80)
    let left  = width
    let right = 1

    for linenr in range(a:firstline, a:lastline)
        let line = getline(linenr)
        if line =~ '^$'
            continue
        endif

        let l = match(line, '\S') + 1
        if l < left
            let left = l
        endif

        let r = len(line)
        if r > right
            let right = r
        endif
    endfor

    if left > right
        echoerr 'No valid region found!'
        return
    endif
    if right > width
        echoerr 'Width is too small!'
        return
    endif

    let mean = float2nr(round((left + (width - right)) / 2.0))

    if mean > left
        for linenr in range(a:firstline, a:lastline)
            let line = getline(linenr)
            if line =~ '^$'
                continue
            endif
            let padding = repeat(' ', mean - left)
            let line = substitute(line, '.*', padding . '\0', '')
            call setline(linenr, line)
        endfor
    else
        for linenr in range(a:firstline, a:lastline)
            let line = getline(linenr)
            if line =~ '^$'
                continue
            endif
            let line = substitute(line, '\s\{' . (left - mean) . '\}', '', '')
            call setline(linenr, line)
        endfor
    endif
endfunction

command! -range -nargs=? CenterBlock <line1>,<line2>call CenterBlock(<f-args>)

" CtrlG() {{{2
function! CtrlG() abort
    redir => default
    execute "silent normal! \<C-g>"
    redir END
    " remove weird null bytes from the beginning
    let default = substitute(default, '^.\{-}\ze"', '', '')
    echo default fnamemodify(getcwd(), ':~')
endfunction
nnoremap <C-g> :call CtrlG()<CR>

" DiffOrig() {{{2
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
endif

" s:fakemap() {{{2
function! s:fakemap(target) abort
    execute 'map <Plug>Fake' . s:fakemap_idx . ' ' . a:target
    let s:fakemap_idx += 1
endfunction
let s:fakemap_idx = 0

" FindAutocmdTouching() {{{2
" Find autocmds that set certain parameters
" From https://groups.google.com/group/vim_use/msg/91d0d2bd87ce59e1
function! FindAutocmdTouching(...)
    " capture the text of existing autocmds
    redir => aucmds
    silent! au
    redir END
    let found = {}
    let evt = 'unknown'
    for line in split(aucmds, '\n')
        " lines starting with non-whitespace are event names
        if line =~ '^\S'
            let evt = line
            continue
        endif
        " add an entry if the line matches any of the passed patterns
        if len(filter(copy(a:000), 'line =~ v:val'))
            let found[evt] = get(found, evt, []) + [line]
        endif
    endfor

    " print a small report of what was found
    if len(found)
        for [k, v] in items(found)
            echo "autocmd" k
            for line in v
                echo line
            endfor
        endfor
    else
        echo "None found"
    endif
endfun

" check for the two variants of 'spellcapcheck'
"call FindAutocmdTouching('spellcapcheck','spc')

" GenerateFoldText() {{{2
" adjusted from http://vim.wikia.com/wiki/Customize_text_for_closed_folds
function! GenerateFoldText()
    let line = getline(v:foldstart)
    if match(line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$') == 0
        " Fold is a comment block starting with '/*' or '//'
        " Use the text of the first non-empty line for the foldtext
        let initial = substitute(line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '')
        let linenum = v:foldstart + 1
        while linenum < v:foldend
            let line            = getline(linenum)
            let comment_content = substitute(line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g')
            if comment_content != ''
                break
            endif
            let linenum = linenum + 1
        endwhile
        let text = initial . ' ' . comment_content
    else
        let text = line

        " Foldtext can't display tabs so replace them with spaces
        let indent = indent(v:foldstart)
        let text   = substitute(text, '^\t\+', repeat(' ', indent), '')

        " Replace content between {} with {...}
        let startbrace = substitute(line, '^.*{[ \t]*$', '{', 'g')
        if startbrace == '{'
            let line     = getline(v:foldend)
            let endbrace = substitute(line, '^[ \t]*}\(.*\)$', '}', 'g')
            if endbrace == '}'
                let text .= substitute(line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
            endif
        endif
    endif
    let foldlen = v:foldend - v:foldstart + 1
    let percent = printf("[%.1f", (foldlen * 1.0)/line('$') * 100) . "%] "
    let info    = " " . foldlen . " lines " . percent . repeat('+--', v:foldlevel) . '|'
    let text   .= repeat(' ', 100)
    let sign_w  = empty(quickfixsigns#marks#GetList('%')) ? 0 : 2
    let len     = min([winwidth(0) - (&number * &numberwidth) - &foldcolumn - sign_w, 100])
    let text    = strpart(text, 0, len - strlen(info))
    return text . info
endfunction

" GenerateTabLine() {{{2
if exists("+showtabline")
    function! GenerateTabLine()
        let s = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
            let buflist = tabpagebuflist(i)
            let winnr = tabpagewinnr(i)
            let s .= '%' . i . 'T'
            let s .= (i == t ? '%5*' : '%4*')
            let s .= ' '
            let s .= i . ':'
"            let s .= winnr . '/' . tabpagewinnr(i,'$')
            let s .= tabpagewinnr(i,'$')
            let mod = '%6*'
            let j = 1
            while j <= tabpagewinnr(i,'$')
                if getbufvar(buflist[j - 1], "&modified") != 0
                    let mod .= '%#StatusLineModFlag#*'
                    break
                endif
                let j = j + 1
            endwhile
            let s .= mod
            let s .= ' %*'
            let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
            let file = bufname(buflist[winnr - 1])
            let file = fnamemodify(file, ':p:t')
            if file == ''
                let file = '[No Name]'
            endif
            let s .= file
"            let s .= file . ' '
            let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
        return s
    endfunction
"    set stal=2
endif

" GenCscopeAndTags() {{{2
function! GenCscopeAndTags()
    " see ~/.ctags
    if g:ctagsbin == ''
        echomsg 'No ctags found!'
        return
    endif
    let ctagsbin = g:ctagsbin
    let userdefs = tagbar#getusertypes()
    for type in values(userdefs)
        if has_key(type, 'deffile')
            let ctagsbin .= ' --options=' . expand(type.deffile)
        endif
    endfor

    if filereadable("cscope.files")
        execute '!cscope -qbc'
        execute '!' . ctagsbin . ' -L cscope.files'
    else
        execute '!cscope -Rqbc'
        execute '!' . ctagsbin . ' -R'
    endif
    if filereadable('cscope.out')
        if cscope_connection(2, "cscope.out") == 0
            execute 'cs add cscope.out'
        else
            execute 'cs reset'
        endif
    endif
"    execute 'CCTreeLoadDB cscope.out'
endfunction

" InsertGuards() {{{2
function! InsertGuards()
    let guardname = "_" . substitute(toupper(expand("%:t")), "[\\.-]", "_", "g") . "_"
    execute "normal! ggI#ifndef " . guardname
    execute "normal! o#define " . guardname . " "
    execute "normal! Go#endif /* " . guardname . " */"
    normal! kk
endfunction

" LoadLocalVimrcs() {{{2
function! LoadLocalVimrcs()
    let configs = reverse(findfile('.vimrc.local', '.;', -1))
    for config in configs
        if filereadable(config)
            execute 'sandbox source ' . config
        endif
    endfor
endfunction
autocmd vimrc BufNewFile,BufReadPost,FileType * call LoadLocalVimrcs()

" s:profile_script_sort() {{{2
" From https://github.com/vheon/dotvim/blob/master/autoload/profile.vim
function! s:profile_script_sort()
    let timings = []
    g/^SCRIPT/call add(
        \ timings,
        \ [
            \ getline('.')[len('SCRIPT '):],
            \ matchstr(getline(line('.') + 1),
            \ '^Sourced \zs\d\+')
        \ ] + map(getline(line('.') + 2, line('.') + 3), 'matchstr(v:val, ''\d\+\.\d\+$'')')
    \ )
    enew
    setl ft=vim
    call setline('.',
               \ ['count total (s) self (s) script'] + map(copy(timings), 'printf("%5u %9s %8s %s", v:val[1], v:val[2], v:val[3], v:val[0])'))
    2,$sort! /\d\s\+\zs\d\.\d\{6}/ r
endfunction
command -nargs=0 ProfileScriptSort call s:profile_script_sort()

" QfDo() {{{2
" http://stackoverflow.com/questions/4792561/how-to-do-search-replace-with-ack-in-vim
" http://vimcasts.org/episodes/project-wide-find-and-replace/
command! -nargs=+ QfDo call QfDo(<q-args>)
function! QfDo(command)
    " Create a dictionary so that we can get the list of buffers rather than
    " the list of lines in buffers (easy way to get unique entries)
    let buffer_numbers = {}
    " For each entry, use the buffer number as a dictionary key (won't get
    " repeats)
    for fixlist_entry in getqflist()
        let buffer_numbers[fixlist_entry.bufnr] = 1
    endfor

    for buf in keys(buffer_numbers)
        execute 'buffer' buf
        execute a:command
        update
    endfor
endfunction

" Qf2Args() {{{2
" Source: https://github.com/jszakmeister/vimfiles/blob/master/vimrc
function! s:Qf2Args()
    let files = {}
    silent! argdelete *
    for lines in getqflist()
        if lines.bufnr > 0
            let files[bufname(lines.bufnr)] = 1
        endif
    endfor
    for file in keys(files)
        execute "silent argadd " . file
    endfor
endfunction

command! -bar Qf2Args call s:Qf2Args()

" s:RangerChooser() {{{2
function! s:RangerChooser() abort
    let tmpfile = tempname()
    let ranger_cmd = 'ranger --choosefile=' . tmpfile . ' ' . expand('%:p:h')
    if has('gui_running')
        execute '!urxvt -geometry 140x40 -e ' . ranger_cmd
    else
        execute 'silent !' . ranger_cmd
    endif
    if filereadable(tmpfile)
        execute 'edit ' . system('cat ' . tmpfile)
        call system('rm ' . tmpfile)
    endif
    redraw!
endfunction
nnoremap <silent> ,ra :call <SID>RangerChooser()<CR>

" Redir {{{2
" Taken from
" https://github.com/jszakmeister/vimfiles/blob/master/vimrc
" Redirect to register "x":
"   Redir @x
" Redirect to global variable "v":
"   Redir => v
" Disable previous redirection (any of these):
"   Redir
"   Redir end
"   Redir END
" While redirected, the 'more' option is reset to avoid the need
" to press <Space> after each screen of output.
command! -nargs=* -bar Redir
            \ if <q-args> == "" || <q-args> ==? "end" |
            \     set more |
            \     redir END |
            \ else |
            \     redir <args> |
            \     set nomore |
            \ endif

" RunShellCommand() {{{2
function! s:RunShellCommand(cmdline)
    botright new
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile
    setlocal nowrap
    nmap <buffer> q :close<cr>
"    call setline(1,a:cmdline)
"    call setline(2,substitute(a:cmdline,'.','=','g'))
    if v:version >= 702
        if stridx(a:cmdline, "git") == 0
            setlocal filetype=git
        endif
    elseif stridx(a:cmdline, "diff") >= 0
        set filetype=diff
    endif
    execute 'silent 0read !'.escape(a:cmdline,'%#')
    setlocal nomodifiable
    1
endfunction

command! -complete=file -nargs=* Git   call s:RunShellCommand('git '.<q-args>)
command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)

" SmartTOHtml() {{{2
"A function that inserts links & anchors on a TOhtml export.
" Notice:
" Syntax used is:
"   *> Link
"   => Anchor
function! SmartTOHtml()
    TOhtml
    try
        %s/&quot;\s\+\*&gt; \(.\+\)</" <a href="#\1" style="color: cyan">\1<\/a></g
        %s/&quot;\(-\|\s\)\+\*&gt; \(.\+\)</" \&nbsp;\&nbsp; <a href="#\2" style="color: cyan;">\2<\/a></g
        %s/&quot;\s\+=&gt; \(.\+\)</" <a name="\1" style="color: #fff">\1<\/a></g
    catch
    endtry
    exe ":write!"
    exe ":bd"
endfunction

" s:Spelllang() {{{2
function! s:Spelllang(lang) abort
    let &spelllang = a:lang
    let base = substitute(a:lang, '^\([^_]\+\).*', '\1', '')
    let &spellfile = expand('~/.vim/spell/' . base . '.utf-8.add')
endfunction
function! s:Spelllist(ArgLead, CmdLine, CursorPos) abort
    let langs = ['en_nz', 'de']
    return filter(langs, "v:val =~# '^' . a:ArgLead")
endfunction

command -nargs=1 -complete=customlist,s:Spelllist Spelllang call s:Spelllang(<q-args>)

" StripTrailing() {{{2
function! StripTrailing(pattern) range abort
    let savePos = winsaveview()
    let saveFoldEnable = &foldenable
    setlocal nofoldenable
    execute a:firstline . ',' . a:lastline . 'substitute /' . a:pattern . '$//ge'
    let &l:foldenable = saveFoldEnable
    call winrestview(savePos)
endfunction
command! -bar -range=% StripTrailingWhitespace <line1>,<line2>call StripTrailing('\s\+')
command! -bar -range=% StripTrailingCtrlM      <line1>,<line2>call StripTrailing('<C-M>')

" Tab2Space/Space2Tab {{{2
command! -range=% -nargs=0 Tab2Space exec "<line1>,<line2>s/^\\t\\+/\\=substitute(submatch(0), '\\t', "repeat(' ', ".&ts."), 'g')"
command! -range=% -nargs=0 Space2Tab exec "<line1>,<line2>s/^\\( \\{".&ts."\\}\\)\\+/\\=substitute(submatch(0), ' \\{".&ts."\\}', '\\t', 'g')"

" Timestamp() {{{2
function! Timestamp()
    let matchpat = '\v\C%(<Last changed\s*:\s+)\zs\d{4}-\d{2}-\d{2} (\d{2}):\d{2}:\d{2} [+-]\d{4} \a+|<TIMESTAMP>'
    let replpat  = '%Y-%m-%d %H:%M:%S %z %Z'

    for linenr in range(1, 20)
        let line   = getline(linenr)
        let matchl = matchlist(line, matchpat)
        if !empty(matchl)
            let hour = strftime('%H')
            " only update once per hour to avoid messing with the undo buffer
            " too much
            if matchl[1] != hour
                let repl    = strftime(replpat)
                let newline = substitute(line, matchpat, repl, '')
                keepjumps call setline(linenr, newline)
            endif
        endif
    endfor
endfunction
autocmd vimrc BufWritePre * call Timestamp()

" ToggleExpandTab() {{{2
function! ToggleExpandTab()
    if &sts == 4
        setlocal softtabstop=8
        setlocal shiftwidth=8
        setlocal noexpandtab
    else
        setlocal softtabstop=4
        setlocal shiftwidth=4
        setlocal expandtab
    endif
    unlet! b:statusline_tab_warning
    set expandtab?
endfunction

" ToggleFold() {{{2
" Toggle fold state between closed and opened.
" If there is no fold at current line, just moves forward.
" If it is present, reverse its state.
fun! ToggleFold()
    if foldlevel('.') == 0
        normal! l
    else
        if foldclosed('.') < 0
            . foldclose
        else
            . foldopen
        endif
    endif
    " Clear status line
    echo
endfun

" ToggleFullscreen() {{{2
function! ToggleFullscreen()
    if !executable('wmctrl')
        echoerr 'wmctrl not installed!'
        return
    endif
    silent !wmctrl -r :ACTIVE: -b toggle,fullscreen
endfunction
nnoremap <silent> <F11> :call ToggleFullscreen()<CR>

" Options {{{1

" important {{{2
set cpoptions+=$
set cpoptions-=a

" moving around, searching and patterns {{{2

" list of flags specifying which commands wrap to another line (local to window)
set whichwrap=<,>,b,s,[,]
" change to directory of file in buffer
"set autochdir

" show match for partly typed search command
set incsearch
" ignore case when using a search pattern
set ignorecase
" override 'ignorecase' when pattern has upper case characters
set smartcase

" pattern for a macro definition line (global or local to buffer)
set define=^\\(\\s*#\\s*define\\\|[a-z]*\\s*const\\s*[a-z]*\\)

" tags {{{2

" when completing tags in Insert mode show more info
set showfulltag
" use cscope for tag commands
set nocscopetag
" give messages when adding a cscope database
set cscopeverbose
" When to open a quickfix window for cscope
set cscopequickfix=s-,c-,d-,i-,t-,e-

" displaying text {{{2

" number of screen lines to show around the cursor
set scrolloff=5
" minimal number of columns to keep left and right of the cursor
set sidescrolloff=5

" long lines wrap
set wrap
" wrap long lines at a character in 'breakat' (local to window)
set nolinebreak
" which characters might cause a line break
"set breakat=\ ^I
" string to put before wrapped screen lines
let &showbreak = '↪ '

" include "lastline" to show the last line even if it doesn't fit
" include "uhex" to show unprintable characters as a hex number
set display=lastline,uhex
" characters to use for the status line, folds and filler lines
set fillchars=
" number of lines used for the command-line
"set cmdheight=2
" don't redraw while executing macros
set lazyredraw

" show <Tab> as ^I and end-of-line as $ (local to window)
set list
" list of strings used for list mode
set listchars=tab:»-,trail:·,nbsp:×,precedes:«,extends:»
"set listchars=tab:»-,trail:␣,nbsp:×,precedes:«,extends:»

" show the line number for each line (local to window)
set number

" syntax, highlighting and spelling {{{2

" maximum column to look for syntax items
set synmaxcol=800
" highlight all matches for the last used search pattern
set hlsearch
" use GUI colors for the terminal
set termguicolors

" highlight spelling mistakes
set nospell
" list of accepted languages
set spelllang=en_nz
" file that "zg" adds good words to
set spellfile=~/.vim/spell/en.utf-8.add
" pattern to locate the end of a sentence
set spellcapcheck=[.?!]\\_[\\])'\"\	\ ]\\+
" methods used to suggest corrections
set spellsuggest=best,10

let g:tex_comment_nospell = 1

" multiple windows {{{2

" 0, 1 or 2; when to use a status line for the last window
set laststatus=2
" alternate format to be used for a status line
"set statusline=%!GenerateStatusline()
" default height for the preview window
set previewheight=9
" don't unload a buffer when no longer shown in a window
set hidden
" "useopen" and/or "split"; which window to use when jumping to a buffer
set switchbuf=useopen " or usetab
" a new window is put below the current one
"set splitbelow

" multiple tab pages {{{2

if exists("+showtabline")
    " 0, 1 or 2; when to use a tab pages line
    set showtabline=1
    " custom tab pages line
    set tabline=%!GenerateTabLine()
endif

" maximum number of tab pages to open for -p and "tab all"
set tabpagemax=50

" terminal {{{2

" specifies what the cursor looks like in different modes
set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor

" using the mouse {{{2

" list of flags for using the mouse
set mouse=a
" "extend", "popup" or "popup_setpos"; what the right mouse button is used for
set mousemodel=popup
" "xterm", "xterm2", "dec" or "netterm"; type of mouse
if !has('nvim')
    " "xterm", "xterm2", "dec" or "netterm"; type of mouse
    set ttymouse=xterm
endif

" printing {{{2

" list of items that control the format of :hardcopy output
set printoptions=paper:A4,left:5pc,right:5pc,top:5pc,bottom:5pc,syntax:a,number:y
" name of the font to be used for :hardcopy
set printfont=:h8

" expression used to print the PostScript file for :hardcopy
set printexpr=PrintFile(v:fname_in)
function! PrintFile(fname)
"    call system("lp " . (&printdevice == '' ? '' : ' -s -d' . &printdevice) . ' ' . a:fname)
    call system("evince " . a:fname)
    call delete(a:fname)
    return v:shell_error
endfunc

" messages and info {{{2

" list of flags to make messages shorter
set shortmess=aoOtTIc
" show (partial) command keys in the status line
set showcmd
" display the current mode in the status line
set showmode
" show cursor position below each window
set ruler
" pause listings when the screen is full
set more
" start a dialog when a command fails
set confirm
" use a visual bell instead of beeping
"set visualbell

" selecting text {{{2

" 'unnamed' to use the * register like unnamed register
" 'autoselect' to always put selected text into register *
set clipboard=unnamed,unnamedplus

" editing text {{{2

" maximum number of changes that can be undone
set undolevels=1000
" line length above which to break a line (local to buffer)
set textwidth=78
" specifies what <BS>, CTRL-W, etc. can do in Insert mode
set backspace=indent,eol,start
" list of flags that tell how automatic formatting works (local to buffer)
set formatoptions+=r " continue comments when pressing <Enter>
set formatoptions-=o " don't continue comments when pressing o/O
set formatoptions+=n " recognize numbered lists when formatting
set formatoptions+=2 " use indent of second line in paragraph
set formatoptions+=l " don't break long lines that were already too long
if v:version > 703 || v:version == 703 && has('patch541')
    set formatoptions+=j " remove comment markers when joining lines
endif
" pattern to recognize a numbered list (local to buffer)
let &formatlistpat = '^\s*\(\d\+\|\a\)[:.)]\s*'

" specifies how Insert mode completion works for CTRL-N and CTRL-P
" (local to buffer)
set complete-=u " scan the unloaded buffers that are in the buffer list
"set complete+=k " scan the files given with the 'dictionary' option
set complete-=i " scan current and included files

" whether to use a popup menu for Insert mode completion
"set completeopt=longest,menu,preview
set completeopt=longest,menuone

" list of dictionary files for keyword completion (global or local to buffer)
set dictionary=/usr/share/dict/words

" the "~" command behaves like an operator
set tildeop
" When inserting a bracket, briefly jump to its match
set showmatch
" use two spaces after '.' when joining a line
set nojoinspaces
" "alpha", "octal" and/or "hex"; number formats recognized for CTRL-A and
" CTRL-X commands (local to buffer)
set nrformats-=octal

" tabs and indenting {{{2

" number of spaces a <Tab> in the text stands for (local to buffer)
set tabstop=8     " should always be 8
" number of spaces used for each step of (auto)indent (local to buffer)
set shiftwidth=4
" a <Tab> in an indent inserts 'shiftwidth' spaces
set smarttab      " shiftwidth at start of line, tabstop/sts elsewhere
" if non-zero, number of spaces to insert for a <Tab> (local to buffer)
" WARNING: mixes spaces and tabs if >0 and noexpandtab!
if v:version > 703 || v:version == 703 && has("patch693")
    set softtabstop=-1
else
    set softtabstop=4
endif
" round to 'shiftwidth' for "<<" and ">>"
set shiftround
" expand <Tab> to spaces in Insert mode (local to buffer)
set expandtab     " WARNING: don't unset if ts != sw

" automatically set the indent of a new line (local to buffer)
set autoindent
" do clever autoindenting (local to buffer)
" more or less deprecated in favor of cindent and indentexpr
"set smartindent

" folding {{{2

" set to display all folds open (local to window)
set nofoldenable
" folds with a level higher than this number will be closed (local to window)
"set foldlevel=100
" width of the column used to indicate folds (local to window)
"set foldcolumn=3
" expression used to display the text of a closed fold
set foldtext=GenerateFoldText()
" specifies for which commands a fold will be opened
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
" maximum fold depth for when 'foldmethod is "indent" or "syntax" (local to window)
set foldnestmax=2

let g:vimsyn_folding = 'afmpPrt'

" diff mode {{{2

" options for using diff mode
set diffopt=filler,vertical

function s:diffexpr()
    let opt = "--text --binary --minimal "
    if &diffopt =~ "icase"
        let opt .= "-i "
    endif
    if &diffopt =~ "iwhite"
        let opt .= "-b "
    endif
    if exists("g:diffargs") && g:diffargs != ""
        let opt .= g:diffargs . " "
    endif
    silent execute "!diff " . opt . v:fname_in . " " . v:fname_new .
                \  " > " . v:fname_out
endfunction
let &diffexpr = s:sid() . "diffexpr()"

" mapping {{{2
" allow timing out halfway into a mapping
set timeout
" allow timing out halfway into a key code
set ttimeout
" time in msec for 'timeout'
set timeoutlen=1000
" time in msec for 'ttimeout'
set ttimeoutlen=10

" reading and writing files {{{2

" enable using settings from modelines when reading a file (local to buffer)
set modeline
" number of lines to check for modelines
set modelines=5
" list of file formats to look for when editing a file
set fileformats=unix,dos,mac

" keep a backup after overwriting a file
"set backup
" list of directories to put backup files in
if has('nvim')
    set backupdir=.,$XDG_STATE_HOME/nvim/backup//
else
    set backupdir=.,$XDG_STATE_HOME/vim/backup//
endif

" automatically read a file when it was modified outside of Vim
" (global or local to buffer)
set autoread

" keep oldest version of a file; specifies file name extension
"set patchmode=.orig

" the swap file {{{2

" list of directories for the swap file
if has('nvim')
    set directory=$XDG_STATE_HOME/nvim/swap//
else
    set directory=$XDG_STATE_HOME/vim/swap//
endif
" number of characters typed to cause a swap file update
set updatecount=100
" time in msec after which the swap file will be updated
set updatetime=2000

" command line editing {{{2

" how many command lines are remembered
set history=1000

" specifies how command line completion works
set wildmode=list:longest,full
" list of file name extensions that have a lower priority
set suffixes=.pdf,.bak,~,.info,.log,.bbl,.blg,.brf,.cb,.ind,.ilg,.inx,.nav,.snm,.out
" list of file name extensions added when searching for a file (local to buffer)
set suffixesadd=.rb
" list of patterns to ignore files for file name completion
set wildignore=tags,*.o,CVS,.svn,.git,*.aux,*.sw[po],*.idx,*.hi,*.dvi,*.lof,*.lol,*.toc,*.class,*.zwc,obj*/**,target/**,*.pyc
" ignore case when completing file names
set wildignorecase
" command-line completion shows a list of matches
"set wildmenu

if has('nvim')
    set undodir=$XDG_STATE_HOME/nvim/undo//
    set undofile
elseif has('persistent_undo')
    set undodir=$XDG_STATE_HOME/vim/undo/
    set undofile
endif

" running make and jumping to errors {{{2

" program used for the ":grep" command (global or local to buffer)
if executable('rg')
    set grepprg=rg\ --no-heading\ --color\ never\ --column\ --smart-case
    set grepformat^=%f:%l:%c:%m
endif

" language specific {{{2

" Avoid command-line redraw on every entered character by turning off Arabic
" shaping (which is implemented poorly).
if has('arabic')
    set noarabicshape
endif

" multi-byte characters {{{2

" automatically detected character encodings
set fileencodings=ucs-bom,utf-8,default,latin1

" various {{{2

filetype plugin indent on
syntax enable

" when to use virtual editing: "block", "insert" and/or "all"
set virtualedit=all
" list of words that specifies what to put in a session file
set sessionoptions=blank,buffers,curdir,folds,help,slash,tabpages,unix,winsize
" list that specifies what to write in the viminfo file
if has('nvim')
    set shada=!,'20,<50,h,r/tmp,r/mnt,r/media,s50,n$XDG_STATE_HOME/nvim/main.shada
else
    set viminfo=!,'20,<50,h,r/tmp,r/mnt,r/media,s50,n$XDG_STATE_HOME/vim/viminfo
endif

" see ft-tex-plugin
let g:tex_flavor = "latex"

" see ft-sh-syntax
let g:is_bash = 1

let g:python_highlight_all = 1

" Highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" Neovim {{{2

if has('nvim')
    set inccommand=nosplit
endif

" Colorscheme {{{1
let g:vim_material_statuscolours = {
    \ 'NONE'         : [['#c2bfa5', '#000000', 'none'], ['#1c1c1c', '#7f7f7f', 'none']],
    \ 'ModeNormal'   : [['#39adb5', '#fafafa', 'bold'], [                            ]],
    \ 'ModeInsert'   : [['#7c4dff', '#fafafa', 'bold'], [                            ]],
    \ 'FilePath'     : [['#b0bec5', '#000000', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'FileName'     : [['#b0bec5', '#000000', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'ModFlag'      : [['#b0bec5', '#e53935', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'BufFlag'      : [['#b0bec5', '#000000', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'FileType'     : [['#c2bfa5', '#000000', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'Branch'       : [['#c2bfa5', '#000000', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'BranchS'      : [['#c2bfa5', '#000000', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'FunctionName' : [['#ebf4f3', '#90a4ae', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'FileFormat'   : [['#ebf4f3', '#90a4ae', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'FileEncoding' : [['#ebf4f3', '#90a4ae', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'Separator'    : [['#ebf4f3', '#90a4ae', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'ExpandTab'    : [['#c2bfa5', '#111111', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'LineColumn'   : [['#c2bfa5', '#000000', 'none'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'LinePercent'  : [['#c2bfa5', '#303030', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'Error'        : [['#e53935', '#fafafa', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'Warning'      : [['#ffb62c', '#fafafa', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
    \ 'Ale'          : [['#b0bec5', '#e53935', 'bold'], ['#ebf4f3', '#90a4ae', 'none']],
\ }

" Based on https://github.com/altercation/solarized/issues/102#issuecomment-275269574
" and https://github.com/xolox/vim-colorscheme-switcher

if !exists('s:known_links')
    let s:known_links = {}
endif

function! s:find_links() " {{{2
    " Find and remember links between highlighting groups.
    redir => listing
    try
        silent highlight
    finally
        redir END
    endtry
    for line in split(listing, "\n")
        let tokens = split(line)
        " We're looking for lines like "String xxx links to Constant" in the
        " output of the :highlight command.
        if len(tokens) == 5 && tokens[1] == 'xxx' && tokens[2] == 'links' && tokens[3] == 'to'
            let fromgroup = tokens[0]
            let togroup = tokens[4]
            let s:known_links[fromgroup] = togroup
        endif
    endfor
endfunction

function! s:restore_links() " {{{2
    " Restore broken links between highlighting groups.
    redir => listing
    try
        silent highlight
    finally
        redir END
    endtry
    let num_restored = 0
    for line in split(listing, "\n")
        let tokens = split(line)
        " We're looking for lines like "String xxx cleared" in the
        " output of the :highlight command.
        if len(tokens) == 3 && tokens[1] == 'xxx' && tokens[2] == 'cleared'
            let fromgroup = tokens[0]
            let togroup = get(s:known_links, fromgroup, '')
            if !empty(togroup)
                execute 'hi link' fromgroup togroup
                let num_restored += 1
            endif
        endif
    endfor
endfunction

function! s:accurate_colorscheme(colo_name)
    call s:find_links()
    exec "colorscheme " a:colo_name
    call s:restore_links()
endfunction

command! -nargs=1 -complete=color MyColorscheme call s:accurate_colorscheme(<q-args>)

function! s:determine_colorscheme() abort " {{{2
    if has('nvim')
        call system(["is-dark-mode"])
    else
        call system("is-dark-mode")
    endif
    if v:shell_error
        if get(g:, "colors_name", "") != "vim-material"
            set background=light
            call s:accurate_colorscheme("vim-material")
        endif
    else
        if get(g:, "colors_name", "") != "desert"
            set background=dark
            call s:accurate_colorscheme("desert")
        endif
    endif
endfunction
command! DetermineColorscheme call s:determine_colorscheme()

call s:determine_colorscheme()
" autocmd vimrc CursorHold,CursorHoldI * nested call s:determine_colorscheme()
" Workaround for some highlighting issues
autocmd ColorScheme * exe 'set filetype=' . &filetype

" Plugin and script options {{{1

" ALE {{{2
let g:ale_lint_delay = 500

let g:ale_linters = {
\   'python': ['mypy', 'ruff'],
\}
let g:ale_python_pylint_auto_pipenv = 1
let g:ale_rust_cargo_use_clippy = 1

let g:ale_fixers = {
\   'python': ['black', 'ruff'],
\   'rust': ['rustfmt'],
\}
let g:ale_fix_on_save = 1

let g:ale_running = 0
augroup AleRunning
    autocmd!
    autocmd User ALELintPre  let g:ale_running = 1 | redrawstatus
    autocmd User ALELintPost let g:ale_running = 0 | redrawstatus
augroup END


" bufexplorer {{{2
let g:bufExplorerDisableDefaultKeyMapping=1    " Disable mapping.
nnoremap <silent> <leader>be :BufExplorer<CR>

" cecutil.vim {{{2
call s:fakemap('<Plug>RestoreWinPosn')
call s:fakemap('<Plug>SaveWinPosn')

" Ctrl-P {{{2
let g:ctrlp_map = ''
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }

" https://github.com/jszakmeister/vimfiles/blob/master/vimrc
" Define prefix mapping for CtrlP plugin so that buffer-local mappings
" for CTRL-P (such as in Tagbar) will override all CtrlP plugin mappings.
nmap <C-P> <SNR>CtrlP.....

" An incomplete mapping should do nothing.
nnoremap <SNR>CtrlP..... <Nop>

nnoremap <SNR>CtrlP.....<C-B> :<C-U>CtrlPBookmarkDir<CR>
nnoremap <SNR>CtrlP.....c     :<C-U>CtrlPChange<CR>
nnoremap <SNR>CtrlP.....C     :<C-U>CtrlPChangeAll<CR>
nnoremap <SNR>CtrlP.....<C-D> :<C-U>CtrlPDir<CR>
nnoremap <SNR>CtrlP.....<C-F> :<C-U>CtrlPCurFile<CR>
nnoremap <SNR>CtrlP.....<C-L> :<C-U>CtrlPLine<CR>
nnoremap <SNR>CtrlP.....<C-M> :<C-U>CtrlPMRU<CR>
nnoremap <SNR>CtrlP.....m     :<C-U>CtrlPMixed<CR>

" Mnemonic: "open files"
nnoremap <SNR>CtrlP.....<C-O> :<C-U>CtrlPBuffer<CR>
nnoremap <SNR>CtrlP.....<C-P> :<C-U>CtrlP<CR>
nnoremap <SNR>CtrlP.....<C-Q> :<C-U>CtrlPQuickfix<CR>
nnoremap <SNR>CtrlP.....<C-R> :<C-U>CtrlPRoot<CR>
nnoremap <SNR>CtrlP.....<C-T> :<C-U>CtrlPTag<CR>
nnoremap <SNR>CtrlP.....t     :<C-U>CtrlPBufTag<CR>
nnoremap <SNR>CtrlP.....T     :<C-U>CtrlPBufTagAll<CR>
nnoremap <SNR>CtrlP.....<C-U> :<C-U>CtrlPUndo<CR>

let g:ctrlp_working_path_mode = 'a'
let g:ctrlp_prompt_mappings = {
    \ 'PrtBS()'      : ['<bs>', '<c-]>', '<c-h>'],
    \ 'PrtCurLeft()' : ['<left>', '<c-^>'],
\ }
let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
let g:ctrlp_mruf_exclude = '/tmp/.*'
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
    \ 'file': '\.exe$\|\.so$\|\.dll$',
\ }
let g:ctrlp_max_files = 0
let g:ctrlp_user_command = {
    \ 'types': {
        \ 1: ['.git/', 'cd %s && git ls-files -oc --exclude-standard'],
        \ 2: ['.hg/', 'hg --cwd %s locate -I .'],
    \ },
    \ 'fallback': 'find %s -type f'
\ }
let g:ctrlp_open_new_file = 'r'
let g:ctrlp_lazy_update = 0
let g:ctrlp_mruf_relative = 0
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript']

let g:ctrlp_buftag_ctags_bin = g:ctagsbin
let g:ctrlp_buftag_types = {
    \ 'grace' : '--options=' . $HOME . '/.vim/bundle/vim-grace/ctags/grace.cnf --language-force=grace --grace-types=idvtcm'
\ }

" devhelp {{{2
let g:devhelpSearch = 1
let g:devhelpAssistant = 0
let g:devhelpSearchKey = '<F7>'
let g:devhelpWordLength = 5

" EasyAlign {{{2
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
" nmap ga <Plug>(EasyAlign)

" EasyMotion {{{2
let g:EasyMotion_do_mapping = 0
let g:EasyMotion_keys = 'asdfghjkl;qwertyuiopzxcvbnm/'
nmap s <Plug>(easymotion-s2)
xmap s <Plug>(easymotion-s2)
omap z <Plug>(easymotion-s2)

" nmap f <Plug>(easymotion-fl)
" nmap F <Plug>(easymotion-Fl)
" xmap f <Plug>(easymotion-fl)
" xmap F <Plug>(easymotion-Fl)
" omap f <Plug>(easymotion-fl)
" omap F <Plug>(easymotion-Fl)
" nmap t <Plug>(easymotion-tl)
" nmap T <Plug>(easymotion-Tl)
" xmap t <Plug>(easymotion-tl)
" xmap T <Plug>(easymotion-Tl)
" omap t <Plug>(easymotion-tl)
" omap T <Plug>(easymotion-Tl)

" map  / <Plug>(easymotion-sn)
" omap / <Plug>(easymotion-tn)
" map  n <Plug>(easymotion-next)
" map  N <Plug>(easymotion-prev)

" expand-region {{{2
nmap <C-Space> <Plug>(expand_region_expand)
xmap <C-Space> <Plug>(expand_region_expand)
xmap _         <Plug>(expand_region_shrink)

let g:expand_region_text_objects = {
    \ 'iw'  : 0,
    \ 'iW'  : 0,
    \ 'i"'  : 0,
    \ 'i''' : 0,
    \ 'i]'  : 1,
    \ 'ib'  : 1,
    \ 'iB'  : 1,
    \ 'il'  : 0,
    \ 'ip'  : 0,
    \ 'ie'  : 0,
    \ 'if'  : 1,
    \ 'af'  : 1,
\ }

" Fugitive {{{2
" automatically delete fugitive buffers when leaving them
autocmd vimrc BufReadPost fugitive://* set bufhidden=delete

" gitgutter {{{2
let g:gitgutter_map_keys = 0
let g:gitgutter_escape_grep = 1

nmap [c <Plug>(GitGutterPrevHunk)
nmap ]c <Plug>(GitGutterNextHunk)

" GnuPG {{{2
let g:GPGUsePipes = 1

" Mark {{{2
let g:mwPalettes = {
    \ 'custom' : [
        \ { 'guibg': '#A4E57E', 'guifg': 'Black' },
        \ { 'guibg': '#FFDB72', 'guifg': 'Black' },
        \ { 'guibg': '#8CCBEA', 'guifg': 'Black' },
        \ { 'guibg': '#FF7272', 'guifg': 'Black' },
        \ { 'guibg': '#FFB3FF', 'guifg': 'Black' },
        \ { 'guibg': '#9999FF', 'guifg': 'Black' },
    \ ]
\ }

let g:mwDefaultHighlightingPalette = 'custom'

nmap gmm <Plug>MarkSet
xmap gmm <Plug>MarkSet
nmap gmr <Plug>MarkRegex
xmap gmr <Plug>MarkRegex
nmap gmn <Plug>MarkClear
nmap gm* <Plug>MarkSearchCurrentNext
nmap gm# <Plug>MarkSearchCurrentPrev
nmap gm/ <Plug>MarkSearchAnyNext
nmap gm? <Plug>MarkSearchAnyPrev

" NERD_Tree {{{2
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
"let NERDTreeCaseSensitiveSort = 1
" let NERDTreeChDirMode = 2 " change pwd with nerdtree root change
" let NERDTreeHijackNetrw = 0
let NERDTreeCreatePrefix = 'silent keepalt keepjumps'
let NERDTreeIgnore = [
    \ '\~$',
    \ '\.o$',
    \ '\.swp$',
    \ '\.bbl$',
    \ '\.blg$',
    \ '\.fdb_latexmk$',
    \ '\.log$',
    \ '\.orig$',
    \ '\.out$',
    \ '\.pdf$',
    \ '\.pyc$',
    \ '\.zwc$'
\ ]

let g:NERDTreeGitStatusIndicatorMapCustom = {
    \ "Modified"  : "*",
    \ "Staged"    : "+",
    \ "Untracked" : "%",
    \ "Renamed"   : "→",
    \ "Unmerged"  : "=",
    \ "Deleted"   : "-",
    \ "Dirty"     : "*",
    \ "Clean"     : "✓",
    \ 'Ignored'   : '○',
    \ "Unknown"   : "?"
\ }

autocmd vimrc BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" From https://github.com/wincent/wincent/blob/9fcbfb13e97701d2c0f54340f4465536e1381bfb/roles/dotfiles/files/.vim/autoload/autocmds.vim#L5-L10
function! s:nerdtree_select_last_file()
    let previous = expand('#:t')
    if previous != ''
        call search('\v<' . previous . '>')
    endif
endfunction
autocmd vimrc User NERDTreeInit call s:nerdtree_select_last_file()

" s:toggle_nerdtree() {{{3
function! s:toggle_nerdtree() abort
    if exists('t:NERDTreeBufName')
        let nerdtree_open = bufwinnr(t:NERDTreeBufName) != -1
    else
        let nerdtree_open = 0
    endif

    if nerdtree_open
        NERDTreeClose
    else
        NERDTreeFind
    endif
endfunction
" }}}3

nnoremap <silent> <M-e>      :call <SID>toggle_nerdtree()<CR>
nnoremap <silent> <F10>      :NERDTreeToggle<CR>

" netrw {{{2
let g:netrw_liststyle = 1

let g:netrw_nogx = 1
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

" Quickfixsigns {{{2
let g:quickfixsigns_classes = ['qfl', 'marks', 'breakpoints']
let g:quickfixsigns_blacklist_buffer = '\v(^__.*__$)|(^NERD_tree.*)|(^$)'
let g:quickfixsigns_icons = {}
let g:quickfixsigns_echo_map = '<Leader><Leader>q'
" exclude "'." from buffer and "<>^" from global
let g:quickfixsigns#marks#buffer = split('abcdefghijklmnopqrstuvwxyz', '\zs')
let g:quickfixsigns#marks#global = split('ABCDEFGHIJKLMNOPQRSTUVWXYZ', '\zs')

" Rainbow Parentheses {{{2
let g:rainbow_active = 1
let g:rainbow_conf = {
\   'guifgs': ['#daa520', 'Cyan', 'Red', '#2e8b57', '#cd5c5c', '#00ff7f', 'Magenta', '#fa8072'],
\   'ctermfgs': ['178', '51', '196', '29', '167', '48', '201', '209'],
\   'operators': '_,_',
\   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
\   'separately': {
\       '*': {},
\       'lisp': {
\           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
\       },
\       'tex': {
\           'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/'],
\       },
\       'vim': {
\           'parentheses': [
\               'start=/(/ end=/)/',
\               'start=/\[/ end=/\]/',
\               'start=/{/ end=/}/ fold',
\               'start=/(/ end=/)/ containedin=vimFuncBody',
\               'start=/\[/ end=/\]/ containedin=vimFuncBody',
\               'start=/{/ end=/}/ fold containedin=vimFuncBody'
\           ],
\       },
\       'xml': {
\           'parentheses': [
\               'start=/\v\<\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'))?)*\>/ end=#</\z1># fold'
\           ],
\       },
\       'xhtml': {
\           'parentheses': [
\               'start=/\v\<\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'))?)*\>/ end=#</\z1># fold'
\           ],
\       },
\       'html': {
\           'parentheses': [
\               'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'
\           ],
\       },
\       'php': {
\           'parentheses': [
\               'start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold',
\               'start=/(/ end=/)/ containedin=@htmlPreproc contains=@phpClTop',
\               'start=/\[/ end=/\]/ containedin=@htmlPreproc contains=@phpClTop',
\               'start=/{/ end=/}/ containedin=@htmlPreproc contains=@phpClTop'
\           ],
\       },
\       'css': 0,
\       'help': 0,
\   }
\}
nnoremap <silent> gr :RainbowToggle<CR>

" Splice {{{2
let g:splice_prefix = '`'
let g:splice_initial_diff_grid = 1
let g:splice_initial_diff_compare = 1
let g:splice_initial_scrollbind_grid = 1
let g:splice_initial_scrollbind_compare = 1
let g:splice_initial_scrollbind_path = 1

" Table mode {{{2
nmap <expr> <silent>   <Tab> getline('.') =~ '^\s*\|' ? ']\|' :   "\<Tab>"
nmap <expr> <silent> <S-Tab> getline('.') =~ '^\s*\|' ? '[\|' : "\<S-Tab>"

" Tagbar {{{2
let g:tagbar_ctags_bin = g:ctagsbin
let g:tagbar_compact = 1

" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'latex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort' : 0
" \ }
let g:tagbar_type_idl = {
    \ 'ctagstype' : 'xpidl',
    \ 'kinds'     : [
        \ 'p:prototypes',
        \ 'i:interfaces',
        \ 'a:attributes',
        \ 't:types',
        \ 'o:operations'
    \ ]
\ }

nmap <silent> <M-t> :TagbarOpenAutoClose<CR>
nmap <silent>  <F9> :TagbarToggle<CR>

" Targets {{{2
let g:targets_nl = 'nL'

" UltiSnips {{{2
let g:UltiSnipsExpandTrigger = "<C-l>"
let g:UltiSnipsJumpForwardTrigger = "<C-j>"
let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
let g:UltiSnipsListSnippets = "<C-h>"
let g:UltiSnipsSnippetsDir = "~/.vim/UltiSnips"
let g:snips_author = 'Jan Larres <jan@majutsushi.net>'

" undotree {{{2
let g:undotree_WindowLayout = 2
let g:undotree_SetFocusWhenToggle = 1
let g:undotree_DiffCommand = "diff -u"

" vertical-move {{{2
let g:vertical_move_default_mapping = 0
nmap <silent> gj <Plug>(vertical_move_down)
nmap <silent> gk <Plug>(vertical_move_up)
xmap <silent> gj <Plug>(vertical_move_down)
xmap <silent> gk <Plug>(vertical_move_up)

" ZoomWin {{{2
let g:zoomwin_zoomed = 0
function! ZWStatusline(zoomed)
    let g:zoomwin_zoomed = a:zoomed
endfunction
if !exists("g:ZoomWin_funcref")
    let g:ZoomWin_funcref = function("ZWStatusline")
endif

" Abbrevs {{{1
func! Eatchar(pat)
    let c = nr2char(getchar(0))
    return (c =~ a:pat) ? '' : c
endfunc

iab _me Jan Larres
iab _mail jan@majutsushi.net
iab _www http://majutsushi.net

" Correcting those typos.
iab alos also
iab aslo also
iab charcter character
iab charcters characters
iab exmaple example
iab shoudl should
iab seperate separate
iab teh the

iab _ae ä
iab _ue ü
iab _oe ö
iab _ss ß

iab _mfg  Mit freundlichen Grüßen
iab _mfgl Mit freundlichen Grüßen,Jan Larres<C-R>=Eatchar('\s')<CR>
iab _vg Viele Grüße

iab _time <C-R>=strftime("%H:%M")<CR>
" Example: 14:28

iab _date <C-R>=strftime("%a %d %b %Y %T %Z")<CR>
" Example: Di 06 Jun 2006 21:27:59 CEST

if filereadable('~/.vim/abbrevs.vim')
    source ~/.vim/abbrevs.vim
endif


" Mappings {{{1

" Readline behaviour {{{2
" Mostly taken from
" https://github.com/tpope/vim-rsi/blob/master/plugin/rsi.vim
inoremap        <C-a> <C-o>^
inoremap   <C-x><C-a> <C-a>
cnoremap        <C-a> <Home>
cnoremap   <C-x><C-a> <C-a>

inoremap <expr> <C-b> getline('.')=~'^\s*$'&&col('.')>strlen(getline('.'))?"0\<Lt>C-d>\<Lt>Esc>kJs":"\<Lt>Left>"
cnoremap        <C-b> <Left>

inoremap <expr> <C-d> col('.')>strlen(getline('.'))?"\<Lt>C-d>":"\<Lt>Del>"
cnoremap <expr> <C-d> getcmdpos()>strlen(getcmdline())?"\<Lt>C-d>":"\<Lt>Del>"

inoremap <expr> <C-e> col('.')>strlen(getline('.'))\|\|pumvisible()?"\<Lt>C-e>":"\<Lt>End>"

inoremap <expr> <C-f> col('.')>strlen(getline('.'))?"\<Lt>C-f>":"\<Lt>Right>"
cnoremap <expr> <C-f> getcmdpos()>strlen(getcmdline())?&cedit:"\<Lt>Right>"

noremap! <M-b> <S-Left>
noremap! <M-d> <C-O>dw
cnoremap <M-d> <S-Right><C-W>
noremap! <M-BS> <C-W>
noremap! <M-f> <S-Right>
noremap! <M-n> <Down>
noremap! <M-p> <Up>

" Buffers/Files/Tabs {{{2

" Fast open a buffer by searching for a name
" nnoremap <leader>b :buffers<CR>:buffer<space>

function! s:copy_filepath() abort
    let fpath = expand('%:p:~')
    let @+ = fpath
    echo "Copied path to clipboard: " . fpath
endfunction
nnoremap yn :call <SID>copy_filepath()<CR>

nnoremap <M-Left>  :tabprevious<CR>
nnoremap <M-Right> :tabnext<CR>

" delete buffer and close window
nnoremap   <F8> :bd<cr>
" delete buffer, but keep window
nnoremap <S-F8> :call Bclose()<cr>

" change tabs fast
nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt

nnoremap <C-W>e :enew<CR>

nnoremap <leader>v :edit $DOTFILES/vim/vimrc<CR>

" Text manipulation {{{2

nnoremap U :earlier 1f<CR>

" Control-Space for omnicomplete
imap <C-Space> <C-X><C-O>

" This slightly convoluted approach is necessary to work with newer
" YouCompleteMe versions
" Also see https://github.com/vim/vim/issues/2004#issuecomment-324357529
function! s:handle_cr()
    if pumvisible()
        call feedkeys("\<C-y>", 'm')
        return ''
    else
        call feedkeys("\<C-]>\<CR>", 'n')
        return ''
    endif
endfunction
inoremap <silent> <expr> <CR> <SID>handle_cr()

inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-P>\<C-N>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-P>\<C-N>"   : "\<PageUp>"

inoremap <C-F> <C-X><C-F>

" create undo break points
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

" Uppercase word
inoremap <M-u> <Esc>gUiwea

" Swap two words
nnoremap <silent> gW :s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR>`'

" have Y behave analogously to D and C rather than to dd and cc (which is
" already done by yy):
nnoremap Y y$

nnoremap Q gqip

set pastetoggle=<F3>

nnoremap <S-F2> :call ToggleExpandTab()<CR>

" in/de-crease indent/autoindent what you just pasted
" https://twitter.com/dotvimrc/status/347055253318950913
nnoremap >< V`]>
nnoremap <lt>> V`]<
nnoremap =- V`]=

" copy to/from the X clipboard
nnoremap <S-Insert> "+gP
xnoremap <S-Insert> "-d"+P
inoremap <S-Insert> <C-R>+
cnoremap <S-Insert> <C-R>+
inoremap <C-Insert> <C-O>"+y
xnoremap <C-Insert> "+y
xnoremap <S-Del>    "+d
inoremap <C-Del>    <C-O>daw

nnoremap <silent> <leader>ga :GNOMEAlignArguments<CR>

" re-select selection after changing indent
xnoremap > >gv
xnoremap < <gv

inoremap <M-H> <C-d>
inoremap <M-L> <C-t>

vmap  <expr>  <Left>   DVB_Drag('left')
vmap  <expr>  <Right>  DVB_Drag('right')
vmap  <expr>  <Down>   DVB_Drag('down')
vmap  <expr>  <Up>     DVB_Drag('up')
vmap  <expr>  D        DVB_Duplicate()

" Move current line up or down
inoremap <M-K> <Esc>:<C-U>
            \ let oldpos = getpos('.')<CR>
            \ ddkP
            \ :<C-U>call setpos('.', oldpos)<CR>
            \ gki
inoremap <M-J> <Esc>:<C-U>
            \ let oldpos = getpos('.')<CR>
            \ ddp
            \ :<C-U>call setpos('.', oldpos)<CR>
            \ gji

" Ctrl-K comma colon (in Insert mode): UTF-8 single-codepoint ellipsis "..."
" disregard error if (for instance) not in UTF-8
if has("digraphs")
    silent! dig ,:  8230 " HORIZONTAL ELLIPSIS
    silent! dig qi 64259 " LATIN SMALL LIGATURE FFI
    silent! dig ql 64260 " LATIN SMALL LIGATURE FFL
endif

" Fold motions
" https://bitbucket.org/sjl/dotfiles/src/tip/vim/vimrc
onoremap if :<c-u>normal! [zv]z<cr>
onoremap af :<c-u>normal! [zV]z<cr>
vnoremap if :<c-u>normal! ]zv[z<cr>
vnoremap af :<c-u>normal! ]zV[z<cr>

" Moving around {{{2

" make some jumps more intuitive and don't require the '{' to be in the first
" column
nnoremap <silent> [[ ?{<CR>w99[{:nohl<CR>
nnoremap <silent> ][ j0?{<CR>w99[{%/{<CR>:nohl<CR>
nnoremap <silent> ]] ][
xnoremap <silent> [[ ?{<CR>w99[{:<C-U>nohl<CR>gv
xnoremap <silent> ][ j0?{<CR>w99[{%/{<CR>:<C-U>nohl<CR>gv
xnoremap <silent> ]] ][

nnoremap ' `
nnoremap ` '

" move into wrapped lines
nnoremap <silent> j gj
nnoremap <silent> k gk
"nnoremap $ g$   " conflicts with virtualedit
"nnoremap 0 g0
"nnoremap ^ g^
xnoremap <silent> j gj
xnoremap <silent> k gk

" move around in insert mode
inoremap <M-h> <Esc>i
inoremap <M-l> <Esc>la
inoremap <M-k> <Esc>gka
inoremap <M-j> <Esc>gja

" Populate the quickfix window with the last search
function! s:quickfix_search() abort
    if &ignorecase && &smartcase && @/ =~# '[A-Z]'
        let pattern = '\C' . @/
    else
        let pattern = @/
    endif
    execute 'lvimgrep /' . pattern . '/ %'
    call qftoggle#openlocwin()
endfunction
nnoremap <silent> g/ :<C-u>call <SID>quickfix_search()<CR>

" search for visually selected text
" http://vimcasts.org/episodes/search-for-the-selected-text/
function! s:VSetSearch(cmdtype)
    let temp = @s
    normal! gv"sy
    let @/ = '\V' . substitute(escape(@s, a:cmdtype . '\'), '\n', '\\n', 'g')
    let @s = temp
endfunction

xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

" substitute visual selection
xnoremap & "*y<Esc>:<c-u>%s/<c-r>=substitute(escape(@*, '\/.*$^~[]'), "\n", '\\n', "g")<cr>/

" Display {{{2

" toggle folds
nnoremap <space> :call ToggleFold()<CR>

" toggle showing 'listchars'
nnoremap <F2> :set invlist list?<CR>
imap <F2> <C-O><F2>
xmap <F2> <Esc><F2>gv

nnoremap <silent> zi
    \ :if &foldenable <Bar>
    \     setlocal nofoldenable <Bar>
    \     setlocal foldcolumn=0 <Bar>
    \ else <Bar>
    \     setlocal foldenable <Bar>
    \     setlocal foldcolumn=1 <Bar>
    \ endif<CR>

nnoremap <silent> <C-l> :if &diff <Bar> diffupdate <Bar> endif<CR>:nohlsearch<CR>:syntax sync fromstart<CR><C-l>

" Windows {{{2

" Easier movement between windows
nnoremap <silent> <M-h> :TmuxNavigateLeft<cr>
nnoremap <silent> <M-j> :TmuxNavigateDown<cr>
nnoremap <silent> <M-k> :TmuxNavigateUp<cr>
nnoremap <silent> <M-l> :TmuxNavigateRight<cr>
nnoremap <silent> <M-p> :TmuxNavigatePrevious<cr>
if has('nvim')
    tnoremap <silent> <M-h> :TmuxNavigateLeft<cr>
    tnoremap <silent> <M-j> :TmuxNavigateDown<cr>
    tnoremap <silent> <M-k> :TmuxNavigateUp<cr>
    tnoremap <silent> <M-l> :TmuxNavigateRight<cr>
    tnoremap <silent> <M-p> :TmuxNavigatePrevious<cr>
endif

" Change window size
nnoremap <M->> <C-W>>
nnoremap <M-<> <C-W><
nnoremap <M-+> <C-W>+
nnoremap <M--> <C-W>-
nnoremap <M-=> <C-W>=

nnoremap <silent> <leader>q :call qftoggle#toggle()<cr>

" Command line {{{2

cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <M-p> <C-p>
cnoremap <M-n> <C-n>

" expand %% to current directory
" cabbrev <expr> %% expand('%:~:h')
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Misc {{{2

 " Like vim-vinegar.
nnoremap <silent> - :silent edit <C-R>=empty(expand('%')) ? '.' : expand('%:p:h')<CR><CR>

" for quick macro playback
"nnoremap Q @q

" Source current or selected lines
vnoremap <leader>S y:execute @@<CR>
nnoremap <leader>S ^vg_y:execute @@<CR>

" run current file as a script
nnoremap <leader>e :execute "Shell " . expand("%:p")<CR>

" Switch to current dir
nnoremap <silent> <leader>cd :cd %:p:h<cr>

nnoremap <S-F10> :call GenCscopeAndTags()<CR>

"inoremap  <Esc><Right>

if has("nvim")
    " Make escape work in the Neovim terminal.
    tnoremap <Esc> <C-\><C-n>
endif

" Modeline {{{1
" vim:tw=78 expandtab comments=\:\" foldmethod=marker foldenable foldcolumn=1
