" Important stuff at the beginning {{{1
set nocompatible
set encoding=utf-8
let mapleader=","

let g:pathogen_disabled = []
if !has('python') || !executable('clang')
    let g:pathogen_disabled += ['clang_complete']
endif
if v:version < 703
    let g:pathogen_disabled += ['gundo']
endif
if !has('gui') && v:version < 703
    let g:pathogen_disabled += ['csapprox']
endif

call pathogen#infect('bundle/{}', '~/src/vim/bundle/{}')
set runtimepath+=$HOME/.vim/xptpersonal

if !isdirectory($HOME . "/.cache/vim") && exists("*mkdir")
    call mkdir($HOME . "/.cache/vim")
endif

" search for exuberant ctags
let ctagsbins  = []
let ctagsbins += [expand('~/src/ctags/ctags/dctags')]
let ctagsbins += ['ctags-exuberant'] " Debian
let ctagsbins += ['exuberant-ctags']
let ctagsbins += ['exctags'] " FreeBSD, NetBSD
let ctagsbins += ['/usr/local/bin/ctags'] " Homebrew
let ctagsbins += ['/opt/local/bin/ctags'] " Macports
let ctagsbins += ['ectags'] " OpenBSD
let ctagsbins += ['ctags']
let ctagsbins += ['ctags.exe']
let ctagsbins += ['tags']
let g:ctagsbin = ''
for ctags in ctagsbins
    if executable(ctags)
        let g:ctagsbin = ctags
        break
    endif
endfor
unlet ctagsbins

" Autocommands {{{1

" remove all autocommands to avoid sourcing them twice
autocmd!

set cursorline
autocmd InsertLeave * set cursorline
autocmd InsertEnter * set nocursorline

" Don't screw up folds when inserting text that might affect them, until
" leaving insert mode. Foldmethod is local to the window. Protect against
" screwing up folding when switching between windows.
autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

" inspired by https://github.com/kana/vim-tabpagecd
autocmd TabEnter * if exists('t:cwd') | execute 'cd ' . fnameescape(t:cwd) | endif
autocmd TabLeave * let t:cwd = getcwd()

autocmd BufNewFile,BufWritePre * call AutoMkDir()

" create undo break point
autocmd CursorHoldI * call feedkeys("\<C-G>u", "nt")

" When switching buffers, preserve window view.
function! IsNotSpecialBuf(buf) abort
    return ((&buftype != "quickfix") &&
          \ !&previewwindow &&
          \ (bufname(a:buf) !~ "NERD_tree") &&
          \ (bufname(a:buf) !~ "__Tag_List__") &&
          \ (bufname(a:buf) !~ "__Tagbar__") &&
          \ (bufname(a:buf) !~ "fugitive*"))
endfunction
if v:version >= 700
    autocmd BufLeave * if(IsNotSpecialBuf("%")) | let b:winview = winsaveview() | endif
    autocmd BufEnter * if(exists('b:winview') && IsNotSpecialBuf("%")) | call winrestview(b:winview) | endif
endif

" automatically give executable permissions if file begins with #!
" and contains" '/bin/' in the path
" From https://github.com/mitechie/pyvim/blob/master/.vimrc
autocmd BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "/bin/" | execute 'silent !chmod u+x <afile>' | endif | endif

" Try to detect the correct expandtab setting
function! s:Detect_et() abort
    let ntabs =   len(filter(getbufline(winbufnr(0), 1, '$'), "v:val =~ '^\t'"))
    let nspaces = len(filter(getbufline(winbufnr(0), 1, '$'), "v:val =~ '^ '"))
    if ntabs > nspaces
        setlocal noexpandtab
        setlocal tabstop=8
        setlocal softtabstop=0
        setlocal shiftwidth=8
    endif
endfunction
autocmd BufReadPost * call s:Detect_et()

" filetype-specific settings
autocmd FileType make      setlocal noexpandtab tabstop=8 shiftwidth=8 softtabstop=0
autocmd FileType gtkrc     setlocal tabstop=2 shiftwidth=2 softtabstop=2
autocmd FileType haskell   compiler ghc
autocmd FileType ruby      setlocal omnifunc=rubycomplete#Complete
autocmd FileType gitcommit setlocal textwidth=72

augroup commentstrings
    autocmd FileType cpp  setlocal commentstring=//%s
    autocmd FileType tmux setlocal commentstring=#%s
augroup END

autocmd BufNewFile,BufReadPost *mutt/fortunes* setlocal textwidth=76
autocmd BufWritePost           *mutt/fortunes* silent !strfile <afile> >/dev/null

" Statusline {{{1
" Adapted from https://github.com/Lokaltog/sync/blob/master/vim/vimrc

" s:StatusLine() {{{2
function! s:StatusLine(new_stl, type, current)
    let current = (a:current ? "" : "NC")
    let new_stl = a:new_stl

    " Prepare current buffer specific text
    " Syntax: <CUR> ... </CUR>
    let new_stl = substitute(new_stl, '<CUR>\(.\{-,}\)</CUR>', (a:current ? '\1' : ''), 'g')

    " Prepare statusline colors
    " Syntax: #[ ... ]
    let new_stl = substitute(new_stl, '#\[Mode\]', '%#StatusLineMode' . a:type . '#', 'g')
    let new_stl = substitute(new_stl, '#\[\(\w\+\)\]',
                           \ '%#StatusLine' . '\1' . current . '#', 'g')

    if &l:statusline ==# new_stl
        " Statusline already set, nothing to do
        return
    endif

    if empty(&l:statusline)
        " No statusline is set, use new_stl
        let &l:statusline = new_stl
    else
        " Check if a custom statusline is set
        let plain_stl = substitute(&l:statusline, '%#StatusLine\w\+#', '', 'g')

        if &l:statusline ==# plain_stl
            " A custom statusline is set, don't modify
            return
        endif

        " No custom statusline is set, use new_stl
        let &l:statusline = new_stl
    endif
endfunction

" s:StatusLineColors() {{{2
function! s:StatusLineColors(colors)
    for name in keys(a:colors)
        let colors = {'c': a:colors[name][0], 'nc': a:colors[name][1]}
        let name = (name == 'NONE' ? '' : name)

        if exists("colors['c'][0]")
            exec 'hi StatusLine' . name .
               \ ' guibg=' . colors['c'][0] .
               \ ' guifg=' . colors['c'][1] .
               \ ' gui='   . colors['c'][2]
        endif

        if exists("colors['nc'][0]")
            exec 'hi StatusLine' . name . 'NC' .
               \ ' guibg=' . colors['nc'][0] .
               \ ' guifg=' . colors['nc'][1] .
               \ ' gui='   . colors['nc'][2]
        endif
    endfor
endfunction

" Colour definitions {{{2
let s:statuscolors = {
    \ 'ModeNormal'   : [[ '#4e9a06', '#ffffff', 'bold'], [                             ]],
    \ 'ModeInsert'   : [[ '#cc0000', '#ffffff', 'bold'], [                             ]],
    \ 'FileName'     : [[ '#c2bfa5', '#000000', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'ModFlag'      : [[ '#c2bfa5', '#cc0000', 'bold'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'BufFlag'      : [[ '#c2bfa5', '#000000', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'FileType'     : [[ '#585858', '#bcbcbc', 'none'], [ '#080808', '#4e4e4e', 'none']],
    \ 'Branch'       : [[ '#585858', '#bcbcbc', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'BranchS'      : [[ '#585858', '#949494', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'FunctionName' : [[ '#1c1c1c', '#9e9e9e', 'none'], [ '#080808', '#4e4e4e', 'none']],
    \ 'FileFormat'   : [[ '#1c1c1c', '#bcbcbc', 'bold'], [ '#080808', '#4e4e4e', 'none']],
    \ 'FileEncoding' : [[ '#1c1c1c', '#bcbcbc', 'bold'], [ '#080808', '#4e4e4e', 'none']],
    \ 'Separator'    : [[ '#1c1c1c', '#6c6c6c', 'none'], [ '#080808', '#4e4e4e', 'none']],
    \ 'ExpandTab'    : [[ '#585858', '#eeeeee', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'LineNumber'   : [[ '#585858', '#bcbcbc', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'LineColumn'   : [[ '#585858', '#bcbcbc', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'LinePercent'  : [[ '#c2bfa5', '#303030', 'bold'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'Warning'      : [[ '#cc0000', '#ffffff', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'Error'        : [[ '#585858', '#ff5f00', 'bold'], [ '#1c1c1c', '#4e4e4e', 'none']]
\ }
" Helper functions {{{2
" GetFileName() {{{3
function! GetFileName()
    if &buftype == 'help'
        return expand('%:p:t')
    elseif &buftype == 'quickfix'
        return '[Quickfix List]'
    elseif bufname('%') == ''
        return '[No Name]'
    else
        let filename = expand('%:p:~:.')
        if winwidth(0) - len(filename) < 65
            let filename = pathshorten(filename)
        endif
        return filename
    endif
endfunction

" GetState() {{{3
function! GetState()
    if &buftype == 'help'
        return 'H'
    elseif &readonly || &buftype == 'nowrite' || &modifiable == 0
        return '-'
    elseif &modified != 0
        return '*'
    else
        return ''
    endif
endfunction

" GetFileformat() {{{3
function! GetFileFormat()
    if &fileformat == '' || &fileformat == 'unix'
        return ''
    else
        return &fileformat
    endif
endfunction

" GetFileencoding() {{{3
function! GetFileEncoding()
    if empty(&fileencoding) || &fileencoding == 'utf-8'
        return ''
    else
        return &fileencoding
    endif
endfunction

" StatuslineTabWarning() {{{3
" Adapted from
" http://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
function! StatuslineTabWarning()
    if !exists("b:statusline_tab_warning")
        let tabs = search('^\t', 'nw') != 0
        let spaces = search('^ ', 'nw') != 0

        if tabs && spaces
            let b:statusline_tab_warning =  'm'
        elseif (spaces && !&et) || (tabs && &et)
            let b:statusline_tab_warning = '!'
        else
            let b:statusline_tab_warning = ''
        endif
    endif
    return b:statusline_tab_warning
endfunction
autocmd CursorHold,BufWritePost * unlet! b:statusline_tab_warning

" StatuslineTrailingSpaceWarning() {{{3
" Adapted from
" http://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
function! StatuslineTrailingSpaceWarning()
    if !exists("b:statusline_trailing_space_warning")
        if search('\s\+$', 'nw') != 0
            let b:statusline_trailing_space_warning = '·'
        else
            let b:statusline_trailing_space_warning = ''
        endif
    endif
    return b:statusline_trailing_space_warning
endfunction
autocmd CursorHold,BufWritePost * unlet! b:statusline_trailing_space_warning

" EclimErrorIndicator() {{{3
function! EclimErrorIndicator() abort
    let loclist = filter(getloclist(0), 'bufnr("%") == v:val.bufnr')
    let errors = filter(copy(loclist), 'tolower(v:val.type) == "e"')

    return len(errors) > 0 ? 'e' : ''
endfunction

" Default statusline {{{2
let g:default_stl  = ""

let g:default_stl .= "<CUR>#[Mode] "
let g:default_stl .= "%{substitute(mode(), '', '^V', 'g')} "
let g:default_stl .= "%{&paste ? '(paste) ' : ''}"
let g:default_stl .= "</CUR>"

" File name
let g:default_stl .= "#[FileName] %{GetFileName()} "

let g:default_stl .= "#[ModFlag]%(%{GetState()} %)#[BufFlag]%w"

let g:default_stl .= "#[Warning]%{EclimErrorIndicator()}"

" File type
let g:default_stl .= "<CUR>%(#[FileType] %{!empty(&ft) ? &ft : '--'}#[BranchS]%)</CUR>"

" Spellcheck language
let g:default_stl .= "<CUR>%(#[FileType]%{&spell ? ':' . &spelllang : ''}#[BranchS]%)</CUR>"

" Git branch
let g:default_stl .= "#[Branch]%("
let g:default_stl .= "%{exists('g:loaded_fugitive') ? substitute(fugitive#statusline(), '\\[GIT(\\([a-z0-9\\-_\\./:]\\+\\))\\]', '<CUR>:</CUR>\\1', 'gi') : ''}"
let g:default_stl .= "%) "

" Syntastic
"let g:default_stl .= "<CUR>%(#[BranchS][>] #[Error]%{substitute(SyntasticStatuslineFlag(), '\\[Syntax: line:\\(\\d\\+\\) \\((\\(\\d\\+\\))\\)\\?\\]', '[>][>][>] SYNTAX \\1 \\2 [>][>][>]', 'i')} %)</CUR>"
"let g:default_stl .= "<CUR>%(#[BranchS][>] #[Error]%{substitute('[Syntax: line:42 (99)]', '\\[Syntax: line:\\(\\d\\+\\) \\((\\(\\d\\+\\))\\)\\?\\]', 'SYNTAX \\1 \\2', 'i')} %)</CUR>"

" Padding/HL group
let g:default_stl .= "#[FunctionName] "

" Truncate here
let g:default_stl .= "%<"

" Function name
" let g:default_stl .= "<CUR>%(%{tagbar#currenttag('%s', '')} %)</CUR>"
let g:default_stl .= "%(%{tagbar#currenttag('%s', '')} %)"

" Current directory
" let g:default_stl .= "%{fnamemodify(getcwd(), ':~')}"

" Right align rest
let g:default_stl .= "%= "

" File format
let g:default_stl .= '<CUR>%(#[FileFormat]%{GetFileFormat()} %)</CUR>'

" File encoding
let g:default_stl .= '<CUR>%(#[FileFormat]%{GetFileEncoding()} %)</CUR>'

" BOM
let g:default_stl .= '<CUR>%(#[FileFormat]%{&bomb ? "BOM" : ""} %)</CUR>'

let g:default_stl .= "#[ExpandTab] "

" ZoomWin state
let g:default_stl .= "%(#[Warning]%{g:zoomwin_stl}#[ExpandTab] %)"

" Tabstop/indent/whitespace settings
let g:default_stl .= "%(#[Warning]"
let g:default_stl .= "%{StatuslineTrailingSpaceWarning()}"
let g:default_stl .= "%{StatuslineTabWarning()}"
let g:default_stl .= "#[ExpandTab] %)"

let g:default_stl .= "%{&expandtab ? 'S' : 'T'}"
let g:default_stl .= "#[LineColumn]:%{&tabstop}:%{&softtabstop}:%{&shiftwidth}"

" Unicode codepoint
"let g:default_stl .= '<CUR>#[LineNumber] U+%04B</CUR>'

" Line/column/virtual column, Line percentage
let g:default_stl .= "#[LineNumber] %04(%l%)#[LineColumn]:%03(%c%V%) "

" Line/column/virtual column, Line percentage
let g:default_stl .= "#[LinePercent] %p%%"

" Current syntax group
"let g:default_stl .= "%{exists('g:synid') && g:synid ? '| '.synIDattr(synID(line('.'), col('.'), 1), 'name').' ' : ''}"

" Autocommands {{{2
augroup StatusLineHighlight
    autocmd!

    autocmd ColorScheme * call <SID>StatusLineColors(s:statuscolors)

    autocmd BufEnter,BufWinEnter,WinEnter,CmdwinEnter,CursorHold,BufWritePost,InsertLeave * call <SID>StatusLine((exists('b:stl') ? b:stl : g:default_stl), 'Normal', 1)
    autocmd BufLeave,BufWinLeave,WinLeave,CmdwinLeave * call <SID>StatusLine((exists('b:stl') ? b:stl : g:default_stl), 'Normal', 0)
    autocmd InsertEnter,CursorHoldI * call <SID>StatusLine((exists('b:stl') ? b:stl : g:default_stl), 'Insert', 1)
augroup END

" Functions {{{1

" UNIX helpers {{{2
" From https://github.com/tpope/vim-eunuch/blob/master/plugin/eunuch.vim
command! -bar -bang Remove :
      \ let v:errmsg = '' |
      \ let s:file = fnamemodify(bufname(<q-args>),':p') |
      \ execute 'bdelete<bang>' |
      \ if v:errmsg ==# '' && delete(s:file) |
      \     echoerr 'Failed to delete "'.s:file.'"' |
      \ endif |
      \ unlet s:file

command! -bar -nargs=1 -bang -complete=file Rename :
      \ let s:file = expand('%:p') |
      \ setlocal modified |
      \ keepalt saveas<bang> <args> |
      \ if s:file !=# expand('%:p') |
      \     call delete(s:file) |
      \ endif |
      \ unlet s:file

command! -bar SudoWrite :
      \ setlocal nomodified |
      \ silent exe 'write !sudo tee % >/dev/null' |
      \ let &modified = v:shell_error

" AutoMkDir() {{{2
" Automatically create dir to write file to if it doesn't exist
function! AutoMkDir()
    let file = expand('<afile>')
    if file =~# '^[a-z]\+:\/\/'
        " Netrw file or similar, don't try creating the directory
        return
    endif
    let required_dir = fnamemodify(file, ':p:h')
    if !isdirectory(required_dir)
        if confirm("Directory '" . required_dir . "' doesn't exist.", "&Abort\n&Create it") != 2
            bdelete
            return
        endif

        try
            call mkdir(required_dir, 'p')
        catch
            if confirm("Can't create '" . required_dir . "'", "&Abort\n&Continue anyway") != 2
                bdelete
                return
            endif
        endtry
    endif
endfunction

" Bclose() {{{2
" delete buffer without closing window
function! Bclose()
    let curbufnr = bufnr("%")
    let altbufnr = bufnr("#")

    if buflisted(altbufnr)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == curbufnr
        new
    endif

    if buflisted(curbufnr)
        execute("bdelete! " . curbufnr)
    endif
endfunction

" CenterBlock() {{{2
function! CenterBlock(...) range
    let width = a:0 > 0 ? a:1 : (&textwidth > 0 ? &textwidth : 80)
    let left  = width
    let right = 1

    for linenr in range(a:firstline, a:lastline)
        let line = getline(linenr)
        if line =~ '^$'
            continue
        endif

        let l = match(line, '\S') + 1
        if l < left
            let left = l
        endif

        let r = len(line)
        if r > right
            let right = r
        endif
    endfor

    if left > right
        echoerr 'No valid region found!'
        return
    endif
    if right > width
        echoerr 'Width is too small!'
        return
    endif

    let mean = float2nr(round((left + (width - right)) / 2.0))

    if mean > left
        for linenr in range(a:firstline, a:lastline)
            let line = getline(linenr)
            if line =~ '^$'
                continue
            endif
            let padding = repeat(' ', mean - left)
            let line = substitute(line, '.*', padding . '\0', '')
            call setline(linenr, line)
        endfor
    else
        for linenr in range(a:firstline, a:lastline)
            let line = getline(linenr)
            if line =~ '^$'
                continue
            endif
            let line = substitute(line, '\s\{' . (left - mean) . '\}', '', '')
            call setline(linenr, line)
        endfor
    endif
endfunction

command! -range -nargs=? CenterBlock <line1>,<line2>call CenterBlock(<f-args>)

" CtrlG() {{{2
function! CtrlG() abort
    redir => default
    execute "silent normal! \<C-g>"
    redir END
    " remove weird null bytes from the beginning
    let default = substitute(default, '^.\{-}\ze"', '', '')
    echo default fnamemodify(getcwd(), ':~')
endfunction
nnoremap <C-g> :call CtrlG()<CR>

" DiffOrig() {{{2
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
endif

" FindAutocmdTouching() {{{2
" Find autocmds that set certain parameters
" From https://groups.google.com/group/vim_use/msg/91d0d2bd87ce59e1
function! FindAutocmdTouching(...)
    " capture the text of existing autocmds
    redir => aucmds
    silent! au
    redir END
    let found = {}
    let evt = 'unknown'
    for line in split(aucmds, '\n')
        " lines starting with non-whitespace are event names
        if line =~ '^\S'
            let evt = line
            continue
        endif
        " add an entry if the line matches any of the passed patterns
        if len(filter(copy(a:000), 'line =~ v:val'))
            let found[evt] = get(found, evt, []) + [line]
        endif
    endfor

    " print a small report of what was found
    if len(found)
        for [k, v] in items(found)
            echo "autocmd" k
            for line in v
                echo line
            endfor
        endfor
    else
        echo "None found"
    endif
endfun

" check for the two variants of 'spellcapcheck'
"call FindAutocmdTouching('spellcapcheck','spc')

" GenerateFoldText() {{{2
" adjusted from http://vim.wikia.com/wiki/Customize_text_for_closed_folds
function! GenerateFoldText()
    let line = getline(v:foldstart)
    if match(line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$') == 0
        " Fold is a comment block starting with '/*' or '//'
        " Use the text of the first non-empty line for the foldtext
        let initial = substitute(line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '')
        let linenum = v:foldstart + 1
        while linenum < v:foldend
            let line            = getline(linenum)
            let comment_content = substitute(line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g')
            if comment_content != ''
                break
            endif
            let linenum = linenum + 1
        endwhile
        let text = initial . ' ' . comment_content
    else
        let text = line

        " Foldtext can't display tabs so replace them with spaces
        let indent = indent(v:foldstart)
        let text   = substitute(text, '^\t\+', repeat(' ', indent), '')

        " Replace content between {} with {...}
        let startbrace = substitute(line, '^.*{[ \t]*$', '{', 'g')
        if startbrace == '{'
            let line     = getline(v:foldend)
            let endbrace = substitute(line, '^[ \t]*}\(.*\)$', '}', 'g')
            if endbrace == '}'
                let text .= substitute(line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
            endif
        endif
    endif
    let foldlen = v:foldend - v:foldstart + 1
    let percent = printf("[%.1f", (foldlen * 1.0)/line('$') * 100) . "%] "
    let info    = " " . foldlen . " lines " . percent . repeat('+--', v:foldlevel) . '|'
    let text   .= repeat(' ', 100)
    let sign_w  = empty(quickfixsigns#marks#GetList('%')) ? 0 : 2
    let len     = min([winwidth(0) - (&number * &numberwidth) - &foldcolumn - sign_w, 100])
    let text    = strpart(text, 0, len - strlen(info))
    return text . info
endfunction

" GenerateTabLine() {{{2
if exists("+showtabline")
    function! GenerateTabLine()
        let s = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
            let buflist = tabpagebuflist(i)
            let winnr = tabpagewinnr(i)
            let s .= '%' . i . 'T'
            let s .= (i == t ? '%5*' : '%4*')
            let s .= ' '
            let s .= i . ':'
"            let s .= winnr . '/' . tabpagewinnr(i,'$')
            let s .= tabpagewinnr(i,'$')
            let mod = '%6*'
            let j = 1
            while j <= tabpagewinnr(i,'$')
                if getbufvar(buflist[j - 1], "&modified") != 0
                    let mod .= '+'
                    break
                endif
                let j = j + 1
            endwhile
            let s .= mod
            let s .= ' %*'
            let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
            let file = bufname(buflist[winnr - 1])
            let file = fnamemodify(file, ':p:t')
            if file == ''
                let file = '[No Name]'
            endif
            let s .= file
"            let s .= file . ' '
            let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
        return s
    endfunction
"    set stal=2
endif

" GenCscopeAndTags() {{{2
function! GenCscopeAndTags()
    " see ~/.ctags
    if g:ctagsbin == ''
        echomsg 'No ctags found!'
        return
    endif
    let ctagsbin = g:ctagsbin
    let userdefs = tagbar#getusertypes()
    for type in values(userdefs)
        if has_key(type, 'deffile')
            let ctagsbin .= ' --options=' . expand(type.deffile)
        endif
    endfor

    if filereadable("cscope.files")
        execute '!cscope -qbc'
        execute '!' . ctagsbin . ' -L cscope.files'
    else
        execute '!cscope -Rqbc'
        execute '!' . ctagsbin . ' -R'
    endif
    if filereadable('cscope.out')
        if cscope_connection(2, "cscope.out") == 0
            execute 'cs add cscope.out'
        else
            execute 'cs reset'
        endif
    endif
"    execute 'CCTreeLoadDB cscope.out'
endfunction

" InsertGuards() {{{2
function! InsertGuards()
    let guardname = "_" . substitute(toupper(expand("%:t")), "[\\.-]", "_", "g") . "_"
    execute "normal! ggI#ifndef " . guardname
    execute "normal! o#define " . guardname . " "
    execute "normal! Go#endif /* " . guardname . " */"
    normal! kk
endfunction

" LoadLocalVimrcs() {{{2
function! LoadLocalVimrcs()
    let configs = reverse(findfile('.vimrc.local', '.;', -1))
    for config in configs
        if filereadable(config)
"            execute 'sandbox source ' . config
            execute 'source ' . config
        endif
    endfor
endfunction
autocmd BufNewFile,BufReadPost * call LoadLocalVimrcs()

" PreviewWord() {{{2
function! PreviewWord(local)
    " don't do this in the preview window
    if &previewwindow
        return
    endif

    let l:editwinnum = winnr()

    let w = expand("<cword>")
    if w =~ '\a'

        " Delete any existing highlight before showing another tag
        silent! wincmd P   " jump to preview window
        if &previewwindow  " if we really get there...
            match none     " delete existing highlight
            silent! exe l:editwinnum . "wincmd w"
        endif

        if a:local == 1
            call PreviewWordLocal(w, l:editwinnum)
        else
            " Try displaying a matching tag for the word under the cursor
            try
                exe "ptjump " . w
            catch
                call PreviewWordLocal(w, l:editwinnum)
            endtry
        endif

        silent! wincmd P
        if &previewwindow
            if has("folding")
                silent! .foldopen
            endif
            call search("$", "b") " to end of previous line
            let w = substitute(w, '\\', '\\\\', "")
            call search('\<\V' . w . '\>') " position cursor on match
            " Add a match highlight to the word at this position
            hi previewWord term=bold ctermbg=green guibg=green
            exe 'match previewWord "\%' . line(".") . 'l\%' . col(".") . 'c\k*"'
            normal zz
            redraw!
            silent! exe l:editwinnum . "wincmd w"
        endif
    endif
endfun

function! PreviewWordLocal(w, editwinnum)
    let l:editpath   = expand("%:p")

    let l:eoldline = line(".")
    let l:eoldcol  = col(".")
    call searchdecl(a:w, 0, 1)
    let l:enewline = line(".")
    let l:enewcol  = col(".")
    call cursor(l:eoldline, l:eoldcol)
    exe "pedit " . l:editpath
    silent! wincmd P
    if &previewwindow
        call cursor(l:enewline, l:enewcol)
        silent! exe a:editwinnum . "wincmd w"
    endif
endfun

" QFDo() {{{2
" http://stackoverflow.com/questions/4792561/how-to-do-search-replace-with-ack-in-vim
" http://vimcasts.org/episodes/project-wide-find-and-replace/
command! -nargs=+ QFDo call QFDo(<q-args>)
function! QFDo(command)
    " Create a dictionary so that we can get the list of buffers rather than
    " the list of lines in buffers (easy way to get unique entries)
    let buffer_numbers = {}
    " For each entry, use the buffer number as a dictionary key (won't get
    " repeats)
    for fixlist_entry in getqflist()
        let buffer_numbers[fixlist_entry.bufnr] = 1
    endfor

    for buf in keys(buffer_numbers)
        execute 'buffer' buf
        execute a:command
        update
    endfor
endfunction

" QuickfixToggle() {{{2
" Source: http://learnvimscriptthehardway.stevelosh.com/chapters/38.html
function! QuickfixToggle()
    if s:quickfix_is_open
        cclose
        let s:quickfix_is_open = 0
        execute s:quickfix_return_to_window . "wincmd w"
    else
        let s:quickfix_return_to_window = winnr()
        if &lines / 4 < 10
            botright copen 10
        else
            execute 'botright copen ' . &lines / 4
        endif
        let s:quickfix_is_open = 1
    endif
endfunction

let s:quickfix_is_open = 0
nnoremap <silent> <leader>q :call QuickfixToggle()<cr>

" RunShellCommand() {{{2
function! s:RunShellCommand(cmdline)
    botright new
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile
    setlocal nowrap
    nmap <buffer> q :close<cr>
"    call setline(1,a:cmdline)
"    call setline(2,substitute(a:cmdline,'.','=','g'))
    if v:version >= 702
        if stridx(a:cmdline, "git") == 0
            setlocal filetype=git
        endif
    elseif stridx(a:cmdline, "diff") >= 0
        set filetype=diff
    endif
    execute 'silent 0read !'.escape(a:cmdline,'%#')
    setlocal nomodifiable
    1
endfunction

command! -complete=file -nargs=* Git   call s:RunShellCommand('git '.<q-args>)
command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)

" SmartTOHtml() {{{2
"A function that inserts links & anchors on a TOhtml export.
" Notice:
" Syntax used is:
"   *> Link
"   => Anchor
function! SmartTOHtml()
    TOhtml
    try
        %s/&quot;\s\+\*&gt; \(.\+\)</" <a href="#\1" style="color: cyan">\1<\/a></g
        %s/&quot;\(-\|\s\)\+\*&gt; \(.\+\)</" \&nbsp;\&nbsp; <a href="#\2" style="color: cyan;">\2<\/a></g
        %s/&quot;\s\+=&gt; \(.\+\)</" <a name="\1" style="color: #fff">\1<\/a></g
    catch
    endtry
    exe ":write!"
    exe ":bd"
endfunction

" s:Spelllang() {{{2
function! s:Spelllang(lang) abort
    let &spelllang = a:lang
    let base = substitute(a:lang, '^\([^_]\+\).*', '\1', '')
    let &spellfile = '~/.vim/spell/' . base . '.utf-8.add'
endfunction
function! s:Spelllist(ArgLead, CmdLine, CursorPos) abort
    let langs = ['en_nz', 'de']
    return filter(langs, "v:val =~# '^' . a:ArgLead")
endfunction

command -nargs=1 -complete=customlist,s:Spelllist Spelllang call s:Spelllang(<q-args>)

" SynStack() {{{2
" Show syntax highlighting groups for word under cursor
function! SynStack()
    if !exists("*synstack")
        return
    endif
    echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
       \ synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')
endfunc
nmap <leader>sy :call SynStack()<CR>

" Tab2Space/Space2Tab {{{2
command! -range=% -nargs=0 Tab2Space exec "<line1>,<line2>s/^\\t\\+/\\=substitute(submatch(0), '\\t', "repeat(' ', ".&ts."), 'g')"
command! -range=% -nargs=0 Space2Tab exec "<line1>,<line2>s/^\\( \\{".&ts."\\}\\)\\+/\\=substitute(submatch(0), ' \\{".&ts."\\}', '\\t', 'g')"

" TextObjectNumber() {{{2
function! s:TextObjectNumber(whole)
    normal! v

    while getline('.')[col('.')] =~# '\v[0-9.]'
        normal! l
    endwhile

    if a:whole
        normal! o

        while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9.]'
            normal! h
        endwhile

        normal! o
    endif
endfunction

onoremap  N :<c-u>call <SID>TextObjectNumber(0)<cr>
xnoremap  N :<c-u>call <SID>TextObjectNumber(0)<cr>
onoremap aN :<c-u>call <SID>TextObjectNumber(1)<cr>
xnoremap aN :<c-u>call <SID>TextObjectNumber(1)<cr>
onoremap iN :<c-u>call <SID>TextObjectNumber(1)<cr>
xnoremap iN :<c-u>call <SID>TextObjectNumber(1)<cr>

" Timestamp() {{{2
function! Timestamp()
    let matchpat = '\v\C%(<Last changed\s*:\s+)\zs\d{4}-\d{2}-\d{2} (\d{2}):\d{2}:\d{2} [+-]\d{4} \a+|<TIMESTAMP>'
    let replpat  = '%Y-%m-%d %H:%M:%S %z %Z'

    for linenr in range(1, 20)
        let line   = getline(linenr)
        let matchl = matchlist(line, matchpat)
        if !empty(matchl)
            let hour = strftime('%H')
            " only update once per hour to avoid messing with the undo buffer
            " too much
            if matchl[1] != hour
                let repl    = strftime(replpat)
                let newline = substitute(line, matchpat, repl, '')
                keepjumps call setline(linenr, newline)
            endif
        endif
    endfor
endfunction
autocmd BufWritePre * call Timestamp()

" ToggleExpandTab() {{{2
function! ToggleExpandTab()
    if &sts == 4
        setlocal softtabstop=8
        setlocal shiftwidth=8
        setlocal noexpandtab
    else
        setlocal softtabstop=4
        setlocal shiftwidth=4
        setlocal expandtab
    endif
    unlet! b:statusline_tab_warning
    set expandtab?
endfunction

" ToggleFold() {{{2
" Toggle fold state between closed and opened.
" If there is no fold at current line, just moves forward.
" If it is present, reverse its state.
fun! ToggleFold()
    if foldlevel('.') == 0
        normal! l
    else
        if foldclosed('.') < 0
            . foldclose
        else
            . foldopen
        endif
    endif
    " Clear status line
    echo
endfun

" ToggleFullscreen() {{{2
function! ToggleFullscreen()
    if !executable('wmctrl')
        echoerr 'wmctrl not installed!'
        return
    endif
    silent !wmctrl -r :ACTIVE: -b toggle,fullscreen,above
endfunction
nnoremap <silent> <F11> :call ToggleFullscreen()<CR>

" Options {{{1

" important {{{2
set cpoptions+=$
set cpoptions-=a

" moving around, searching and patterns {{{2

" list of flags specifying which commands wrap to another line (local to window)
set whichwrap=<,>,b,s,[,]
" change to directory of file in buffer
"set autochdir

" show match for partly typed search command
set incsearch
" ignore case when using a search pattern
set ignorecase
" override 'ignorecase' when pattern has upper case characters
set smartcase

" pattern for a macro definition line (global or local to buffer)
set define=^\\(\\s*#\\s*define\\\|[a-z]*\\s*const\\s*[a-z]*\\)

" tags {{{2

" when completing tags in Insert mode show more info
set showfulltag
" use cscope for tag commands
set nocscopetag
" give messages when adding a cscope database
set cscopeverbose
" When to open a quickfix window for cscope
set cscopequickfix=s-,c-,d-,i-,t-,e-

" displaying text {{{2

" number of screen lines to show around the cursor
set scrolloff=5

" long lines wrap
set wrap
" wrap long lines at a character in 'breakat' (local to window)
set linebreak
" which characters might cause a line break
"set breakat=\ ^I
" string to put before wrapped screen lines
set showbreak=…

" include "lastline" to show the last line even if it doesn't fit
" include "uhex" to show unprintable characters as a hex number
set display=lastline
" characters to use for the status line, folds and filler lines
set fillchars=
" number of lines used for the command-line
"set cmdheight=2
" don't redraw while executing macros
set lazyredraw

" show <Tab> as ^I and end-of-line as $ (local to window)
set list
" list of strings used for list mode
set listchars=tab:»-,trail:·,nbsp:×,precedes:«,extends:»
"set listchars=tab:»-,trail:␣,nbsp:×,precedes:«,extends:»

" show the line number for each line (local to window)
set number

" syntax, highlighting and spelling {{{2

" "dark" or "light"; the background color brightness
set background=dark
" highlight all matches for the last used search pattern
set hlsearch

" highlight spelling mistakes
set nospell
" list of accepted languages
set spelllang=en_nz
" file that "zg" adds good words to
set spellfile=~/.vim/spell/en.utf-8.add
" pattern to locate the end of a sentence
set spellcapcheck=[.?!]\\_[\\])'\"\	\ ]\\+
" methods used to suggest corrections
set spellsuggest=best,10

let g:tex_comment_nospell = 1

" multiple windows {{{2

" 0, 1 or 2; when to use a status line for the last window
set laststatus=2
" alternate format to be used for a status line
"set statusline=%!GenerateStatusline()
" default height for the preview window
set previewheight=9
" don't unload a buffer when no longer shown in a window
set hidden
" "useopen" and/or "split"; which window to use when jumping to a buffer
set switchbuf=useopen " or usetab
" a new window is put below the current one
"set splitbelow

" multiple tab pages {{{2

if exists("+showtabline")
    " 0, 1 or 2; when to use a tab pages line
    set showtabline=1
    " custom tab pages line
    set tabline=%!GenerateTabLine()
endif

" terminal {{{2

" terminal connection is fast
set ttyfast
" show info in the window title
set title
" string to restore the title to when exiting Vim
let &titleold=fnamemodify(&shell, ":t")

if (&term =~ "xterm" || &term =~ "screen-256color")
    set t_Co=256
endif

" idea from http://ft.bewatermyfriend.org/comp/vim/vimrc.html
function! GetScreenTitle()
    let title = 'vim'
    let file  = expand('%:t')
    if !empty(file)
        let title .= '(' . file . ')'
    endif
    if !empty($SSH_CLIENT)
        let title .= '@' . substitute(system('hostname'), '\..*', '', '')
    endif
    return title
endfunction
if &term =~ '^screen'
    let &t_ts = "\<Esc>k"
    let &t_fs = "\<Esc>\\"
    autocmd BufEnter * let &titlestring = GetScreenTitle()
endif

" disable visual bell
set t_vb=

" using the mouse {{{2

" list of flags for using the mouse
set mouse=a
" "extend", "popup" or "popup_setpos"; what the right mouse button is used for
set mousemodel=popup
" "xterm", "xterm2", "dec" or "netterm"; type of mouse
set ttymouse=xterm


" printing {{{2

" list of items that control the format of :hardcopy output
set printoptions=number:y,paper:A4,left:5pc,right:5pc,top:5pc,bottom:5pc
" name of the font to be used for :hardcopy
set printfont=Monospace\ 8

" expression used to print the PostScript file for :hardcopy
set printexpr=PrintFile(v:fname_in)
function! PrintFile(fname)
"    call system("lp " . (&printdevice == '' ? '' : ' -s -d' . &printdevice) . ' ' . a:fname)
    call system("evince " . a:fname)
    call delete(a:fname)
    return v:shell_error
endfunc

" messages and info {{{2

" list of flags to make messages shorter
set shortmess=aoOtI
" show (partial) command keys in the status line
set showcmd
" display the current mode in the status line
set showmode
" show cursor position below each window
set ruler
" pause listings when the screen is full
set more
" start a dialog when a command fails
set confirm
" use a visual bell instead of beeping
"set visualbell

" selecting text {{{2

" 'unnamed' to use the * register like unnamed register
" 'autoselect' to always put selected text into register *
set clipboard=exclude:cons\|linux

" editing text {{{2

" maximum number of changes that can be undone
set undolevels=1000
" line length above which to break a line (local to buffer)
set textwidth=78
" specifies what <BS>, CTRL-W, etc. can do in Insert mode
set backspace=indent,eol,start
" list of flags that tell how automatic formatting works (local to buffer)
set formatoptions+=r " continue comments when pressing <Enter>
set formatoptions+=n " recognize numbered lists when formatting
set formatoptions+=2 " use indent of second line in paragraph
set formatoptions+=l " don't break long lines that were already too long
if v:version >= 703 && has('patch541')
    set formatoptions+=j " remove comment markers when joining lines
endif
" pattern to recognize a numbered list (local to buffer)
let &formatlistpat = '^\s*\(\d\+\|\a\)[:.)]\s*'

" specifies how Insert mode completion works for CTRL-N and CTRL-P
" (local to buffer)
set complete-=u " scan the unloaded buffers that are in the buffer list
"set complete+=k " scan the files given with the 'dictionary' option
set complete-=i " scan current and included files

" whether to use a popup menu for Insert mode completion
"set completeopt=longest,menu,preview
set completeopt=longest,menuone

" list of dictionary files for keyword completion (global or local to buffer)
set dictionary=/usr/share/dict/words

" the "~" command behaves like an operator
set tildeop
" When inserting a bracket, briefly jump to its match
set showmatch
" use two spaces after '.' when joining a line
set nojoinspaces
" "alpha", "octal" and/or "hex"; number formats recognized for CTRL-A and
" CTRL-X commands (local to buffer)
set nrformats-=octal

" tabs and indenting {{{2

" number of spaces a <Tab> in the text stands for (local to buffer)
set tabstop=8     " should always be 8
" number of spaces used for each step of (auto)indent (local to buffer)
set shiftwidth=4
" a <Tab> in an indent inserts 'shiftwidth' spaces
"set smarttab      " shiftwidth at start of line, tabstop/sts elsewhere
" if non-zero, number of spaces to insert for a <Tab> (local to buffer)
set softtabstop=4 " WARNING: mixes spaces and tabs if >0 and noexpandtab!
" round to 'shiftwidth' for "<<" and ">>"
set shiftround
" expand <Tab> to spaces in Insert mode (local to buffer)
set expandtab     " WARNING: don't unset if ts != sw

" automatically set the indent of a new line (local to buffer)
set autoindent
" do clever autoindenting (local to buffer)
" more or less deprecated in favor of cindent and indentexpr
"set smartindent

" folding {{{2

" set to display all folds open (local to window)
set nofoldenable
" folds with a level higher than this number will be closed (local to window)
"set foldlevel=100
" width of the column used to indicate folds (local to window)
"set foldcolumn=3
" expression used to display the text of a closed fold
set foldtext=GenerateFoldText()
" specifies for which commands a fold will be opened
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
" maximum fold depth for when 'foldmethod is "indent" or "syntax" (local to window)
set foldnestmax=2

let g:vimsyn_folding = 'afmpPrt'

" diff mode {{{2

" options for using diff mode
set diffopt=filler,vertical

" mapping {{{2
" allow timing out halfway into a mapping
set timeout
" allow timing out halfway into a key code
set nottimeout
" time in msec for 'timeout'
set timeoutlen=1000
" time in msec for 'ttimeout'
set ttimeoutlen=10

" reading and writing files {{{2

" enable using settings from modelines when reading a file (local to buffer)
set modeline
" number of lines to check for modelines
set modelines=5
" list of file formats to look for when editing a file
set fileformats=unix,dos,mac

" keep a backup after overwriting a file
"set backup
" list of directories to put backup files in
"set backupdir= " where to put backup files

" automatically read a file when it was modified outside of Vim
" (global or local to buffer)
set autoread

" keep oldest version of a file; specifies file name extension
"set patchmode=.orig

" the swap file {{{2

" list of directories for the swap file
"set directory=
" number of characters typed to cause a swap file update
set updatecount=100
" time in msec after which the swap file will be updated
set updatetime=2000

" command line editing {{{2

" how many command lines are remembered
set history=100

" specifies how command line completion works
set wildmode=list:longest,full
" list of file name extensions that have a lower priority
set suffixes=.pdf,.bak,~,.info,.log,.bbl,.blg,.brf,.cb,.ind,.ilg,.inx,.nav,.snm,.out
" list of file name extensions added when searching for a file (local to buffer)
set suffixesadd=.rb
" list of patterns to ignore files for file name completion
set wildignore=tags,*.o,CVS,.svn,.git,*.aux,*.swp,*.idx,*.hi,*.dvi,*.lof,*.lol,*.toc,*.class,*.zwc,obj*/**
" command-line completion shows a list of matches
"set wildmenu
" key used to open the command-line window
set cedit=<C-O>

" running make and jumping to errors {{{2

" program used for the ":grep" command (global or local to buffer)
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor\ --column\ --smart-case
    set grepformat^=%f:%l:%c:%m
else
    set grepprg=ack
endif

" language specific {{{2

" Avoid command-line redraw on every entered character by turning off Arabic
" shaping (which is implemented poorly).
if has('arabic')
    set noarabicshape
endif

" multi-byte characters {{{2

" automatically detected character encodings
set fileencodings=ucs-bom,utf-8,default,latin1

" various {{{2

filetype plugin indent on
syntax enable

let g:CSApprox_attr_map = { 'bold' : 'bold', 'italic' : '', 'sp' : 'fg' }
" must come after terminal color configuration
if !has('gui') && v:version < 703
    colorscheme desert256
else
    colorscheme desert
endif

" when to use virtual editing: "block", "insert" and/or "all"
set virtualedit=all
" list of words that specifies what to put in a session file
set sessionoptions-=options
" list that specifies what to write in the viminfo file
set viminfo=!,'20,<50,h,r/tmp,r/mnt,r/media,s50,n~/.cache/vim/viminfo

" see ft-tex-plugin
let g:tex_flavor = "latex"

" see ft-sh-syntax
let g:is_bash = 1

let g:python_highlight_all = 1

" Highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" Plugin and script options {{{1

" changelog {{{2
let g:changelog_username = "Jan Larres <jan@majutsushi.net>"

" CheckAttach {{{2
let g:attach_check_keywords  = '.doc,.pdf,.xls,.ppt,.rtf,.pps'
let g:attach_check_keywords .= ',attachment,attach,attached,attaching,enclosed'
let g:attach_check_keywords .= ',anhängen,angehängt,Anhang'
let g:attach_check_keywords .= ',CV,resume,cover letter'
let g:checkattach_filebrowser = 'ranger'

" clang_complete {{{2
let g:clang_auto_select = 1
let g:clang_use_library = 1

" code_complete {{{2
let g:completekey = "<c-tab>"

" command-t {{{2
let g:CommandTMaxFiles = 100000
let g:CommandTMatchWindowReverse = 1

" ConqueTerm {{{2
let g:ConqueTerm_StartMessages = 0

" Ctrl-P {{{2
let g:ctrlp_map = '<leader>ff'
let g:ctrlp_cmd = 'CtrlP'
nnoremap <silent> <leader>fb :CtrlPBuffer<CR>
nnoremap <silent> <leader>ft :CtrlPBufTag<CR>

let g:ctrlp_prompt_mappings = {
    \ 'PrtBS()'      : ['<bs>', '<c-]>', '<c-h>'],
    \ 'PrtCurLeft()' : ['<left>', '<c-^>'],
\ }
let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
let g:ctrlp_mruf_exclude = '/tmp/.*'
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
    \ 'file': '\.exe$\|\.so$\|\.dll$',
\ }
let g:ctrlp_max_files = 0
let g:ctrlp_user_command = {
    \ 'types': {
        \ 1: ['.git/', 'git --git-dir=%s/.git ls-files -oc --exclude-standard'],
        \ 2: ['.hg/', 'hg --cwd %s locate -I .'],
    \ },
    \ 'fallback': 'find %s -type f'
\ }
let g:ctrlp_open_new_file = 'r'
let g:ctrlp_lazy_update = 0
let g:ctrlp_mruf_relative = 0
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript']

let g:ctrlp_buftag_types = {
    \ 'grace' : '--options=' . $HOME . '/.vim/bundle/vim-grace/ctags/grace.cnf --language-force=grace --grace-types=idvtcm'
\ }

" devhelp {{{2
let g:devhelpSearch = 1
let g:devhelpAssistant = 0
let g:devhelpSearchKey = '<F7>'
let g:devhelpWordLength = 5

" EasyMotion {{{2
let g:EasyMotion_keys = 'abcdefghijklmnopqrstuvwxyz'

" Eclim {{{2
let g:EclimLoggingDisabled = 1

" expand-region {{{2
let g:expand_region_text_objects = {
    \ 'iw'  : 0,
    \ 'iW'  : 0,
    \ 'i"'  : 0,
    \ 'i''' : 0,
    \ 'i]'  : 1,
    \ 'ib'  : 1,
    \ 'iB'  : 1,
    \ 'il'  : 0,
    \ 'ip'  : 0,
    \ 'ie'  : 0,
    \ 'if'  : 1,
    \ 'af'  : 1,
\ }

" FSwitch {{{2
nnoremap <silent> <Leader>of :FSHere<cr>
nnoremap <silent> <Leader>ol :FSRight<cr>
nnoremap <silent> <Leader>oL :FSSplitRight<cr>
nnoremap <silent> <Leader>oh :FSLeft<cr>
nnoremap <silent> <Leader>oH :FSSplitLeft<cr>
nnoremap <silent> <Leader>ok :FSAbove<cr>
nnoremap <silent> <Leader>oK :FSSplitAbove<cr>
nnoremap <silent> <Leader>oj :FSBelow<cr>
nnoremap <silent> <Leader>oJ :FSSplitBelow<cr>

autocmd BufEnter *.c        let b:fswitchdst  = 'h'
autocmd BufEnter *.c        let b:fswitchlocs = './'
autocmd BufEnter *.cpp,*.cc let b:fswitchdst  = 'h,hpp'
autocmd BufEnter *.cpp,*.cc let b:fswitchlocs = './'
autocmd BufEnter *.h        let b:fswitchdst  = 'cpp,cc,c'
autocmd BufEnter *.h        let b:fswitchlocs = './'

" Fugitive {{{2
" automatically delete fugitive buffers when leaving them
autocmd BufReadPost fugitive://* set bufhidden=delete

" Gitv {{{2
let g:Gitv_OpenHorizontal = 1

" GnuPG {{{2
let g:GPGUsePipes = 1

" Gundo {{{2
nnoremap <leader>u :GundoToggle<CR>

" Latex Box {{{2
let g:LatexBox_completion_close_braces = 0
"let g:LatexBox_latexmk_options = "-pvc"
let g:LatexBox_autojump = 1

" NERD_Tree {{{2
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
"let NERDTreeCaseSensitiveSort = 1
let NERDTreeChDirMode = 2 " change pwd with nerdtree root change
let NERDTreeHijackNetrw = 0
let NERDTreeIgnore = [
    \ '\~$',
    \ '\.o$',
    \ '\.swp$',
    \ '\.bbl$',
    \ '\.blg$',
    \ '\.fdb_latexmk$',
    \ '\.log$',
    \ '\.out$',
    \ '\.pdf$'
\ ]

autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

nmap <silent> <F10> :NERDTreeToggle<CR>
nmap <silent> <leader>nf :NERDTreeFind<CR>

" ProtoDef {{{2
let g:protodefprotogetter = expand('~/.vim/bundle/protodef/pullproto.pl')
let g:protodefctagsexe = g:ctagsbin

" Quickfixsigns {{{2
let g:quickfixsigns_classes = ['qfl', 'loc', 'marks', 'breakpoints']
let g:quickfixsigns_blacklist_buffer = '\v(^__.*__$)|(^NERD_tree.*)|(^$)'
let g:quickfixsigns_icons = {}
" exclude 'p' and 'l' because of xptemplate
" also exclude "'." from buffer and "<>^" from global
let g:quickfixsigns#marks#buffer = split('abcdefghijkmnoqrstuvwxyz', '\zs')
let g:quickfixsigns#marks#global = split('ABCDEFGHIJKLMNOPQRSTUVWXYZ', '\zs')
let g:quickfixsigns#vcsdiff#highlight = {'ADD' : 'QFS_ADD',
                                       \ 'DEL' : 'QFS_DEL',
                                       \ 'CHANGE' : 'QFS_CHANGE'}

" r-plugin {{{2
if executable('urxvt')
    let vimrplugin_term_cmd = "urxvt -title R -e"
else
    let vimrplugin_term = "uxterm"
endif
let vimrplugin_conqueplugin = 1
let vimrplugin_conquevsplit = 1
let vimrplugin_underscore   = 0

" Screen {{{2
let g:ScreenImpl = 'Tmux'
let g:ScreenShellTerminal = 'urxvt'
let g:ScreenShellExpandTabs = 1

function! s:ScreenShellListener()
    if g:ScreenShellActive
        nnoremap <silent> <leader>ss :ScreenSend<cr>
        xnoremap <silent> <leader>ss :ScreenSend<cr>
        nnoremap <silent> <leader>sq :ScreenQuit<cr>
    else
        nnoremap <silent> <leader>ss :ScreenShellVertical<cr>
    endif
endfunction

nnoremap <silent> <leader>ss :ScreenShellVertical<cr>
augroup ScreenShellEnter
    autocmd User * call <SID>ScreenShellListener()
augroup END
augroup ScreenShellExit
    autocmd User * call <SID>ScreenShellListener()
augroup END

" Signify {{{2
let g:signify_vcs_list = ['git']
let g:signify_sign_overwrite = 0

" Splice {{{2
let g:splice_initial_diff_grid = 1
let g:splice_initial_diff_compare = 1
let g:splice_initial_scrollbind_grid = 1
let g:splice_initial_scrollbind_compare = 1
let g:splice_initial_scrollbind_path = 1

" Tagbar {{{2
let g:tagbar_ctags_bin = g:ctagsbin
let g:tagbar_compact = 1

" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'latex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort' : 0
" \ }
let g:tagbar_type_idl = {
    \ 'ctagstype' : 'xpidl',
    \ 'kinds'     : [
        \ 'p:prototypes',
        \ 'i:interfaces',
        \ 'a:attributes',
        \ 't:types',
        \ 'o:operations'
    \ ]
\ }

highlight link TagbarHighlight Cursor
highlight TagbarSignature guifg=yellowgreen
highlight TagbarVisibilityProtected guifg=SkyBlue

nmap <silent>   <F9> :TagbarOpenAutoClose<CR>
nmap <silent> <S-F9> :TagbarToggle<CR>

" TOhtml syntax script {{{2
let html_use_css = 1
let html_number_lines = 0
let use_xhtml = 1
let html_ignore_folding = 1

" UTL {{{2
let g:utl_cfg_hdl_scm_http_system = "silent !xdg-open '%u'"

function! Utl_AddressScheme_mutt(uri, fragment, dispMode)
    let delimit = stridx(a:uri, ':')
    let mid     = strpart(a:uri, delimit + 1)

    if $TERM =~# 'screen'
        let cmd = 'screen '
    elseif executable('urxvt')
        let cmd = 'urxvt -e '
    else
        let cmd = 'xterm -e '
    endif

    let cmd .= expand('~/.etc/bin/mutt-open') . ' ' . mid
    call system(cmd)

    return []
endfunction

" vimplate {{{2
let Vimplate = expand('~/.vim/bundle/vimplate/vimplate')

" setup templates
autocmd BufNewFile *.tex Vimplate LaTeX
autocmd BufNewFile *.sh Vimplate shell
autocmd BufNewFile *.c Vimplate c
autocmd BufNewFile *.vim Vimplate vim
autocmd BufNewFile *.rb Vimplate ruby
autocmd BufNewFile Makefile Vimplate Makefile-C

" voom {{{2
let g:voom_tab_key = '<C-Tab>'
let g:voom_verify_oop = 1
let g:voom_user_command = "runtime! voom_addons/*.vim"

" xptemplate {{{2
let g:xptemplate_key = '<Tab>'
let g:xptemplate_always_show_pum = 0
"let g:xptemplate_brace_complete = '([{'
let g:xptemplate_brace_complete = ''
let g:xptemplate_minimal_prefix = 1
let g:xptemplate_pum_tab_nav = 1
let g:xptemplate_strict = 0
let g:xptemplate_highlight='following,next'
let g:xptemplate_vars = '$author=Jan Larres&$email=jan@majutsushi.net'

" yankring {{{2
let g:yankring_history_dir = '$HOME/.cache/vim'
nnoremap <silent> <leader>y :YRShow<CR>

" ZoomWin {{{2
let g:zoomwin_stl = ''
function! ZWStatusline(zoomed)
    let g:zoomwin_stl = a:zoomed ? 'Z' : ''
endfunction
if !exists("g:ZoomWin_funcref")
    let g:ZoomWin_funcref = function("ZWStatusline")
endif

" Abbrevs {{{1
func! Eatchar(pat)
    let c = nr2char(getchar(0))
    return (c =~ a:pat) ? '' : c
endfunc

iab _me Jan Larres
iab _mail jan@majutsushi.net
iab _www http://majutsushi.net

" Correcting those typos.
iab alos also
iab aslo also
iab charcter character
iab charcters characters
iab exmaple example
iab shoudl should
iab seperate separate
iab teh the

iab _ae ä
iab _ue ü
iab _oe ö
iab _ss ß

iab _mfg  Mit freundlichen Grüßen
iab _mfgl Mit freundlichen Grüßen,Jan Larres<C-R>=Eatchar('\s')<CR>
iab _vg Viele Grüße

iab _time <C-R>=strftime("%H:%M")<CR>
" Example: 14:28

iab _date <C-R>=strftime("%a %d %b %Y %T %Z")<CR>
" Example: Di 06 Jun 2006 21:27:59 CEST

if filereadable('~/.vim/abbrevs.vim')
    source ~/.vim/abbrevs.vim
endif

" Terminal stuff {{{1

" s:MapMetaChars() {{{2
function! s:MapMetaChars() abort
    let metachars  = '0123456789'
    " remove g/ç as it conflicts with xptemplate
    let metachars .= 'abcdefhijklmnopqrstuvwxyz'
    let metachars .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    let metachars .= '+-='

    for char in split(metachars, '\zs')
        execute "set <M-" . char . ">=\e" . char
    endfor
endfunction "}}}2

" s:MapExtraKeys() {{{2
function! s:MapExtraKeys() abort
    " Some key combinations aren't recognized keycodes, therefore we have to
    " do this: http://vim.wikia.com/wiki/Mapping_fast_keycodes_in_terminal_Vim
    let extramaps = {
        \ 'S-CR'    : 'Q13;2~',
        \ 'C-CR'    : 'Q13;5~',
        \ 'C-S-CR'  : 'Q13;6~',
        \ 'C-Space' : 'Q32;5~',
        \ 'M->'     : '>',
        \ 'M-<'     : '<'
    \ }
    if &term =~ '^xterm\|screen'
        let extramaps['C-Insert'] = '[2;5~'
    elseif &term =~ '^rxvt-unicode'
        let extramaps['C-Insert'] = '[2^'
    endif

    let mapc = 0
    for [key, val] in items(extramaps)
        if mapc == 50
            echohl WarningMsg
            echomsg "Unable to map " . key . ": out of spare keycodes"
            echohl None
            break
        endif
        let vkey = (mapc / 25 == 0 ? '' : 'S-') . 'F' . (13 + mapc % 25)
        execute "set  <" . vkey . ">=\e" . val
        execute "map  <" . vkey . "> <" . key . ">"
        execute "map! <" . vkey . "> <" . key . ">"
        let mapc += 1
    endfor
endfunction "}}}2

if &term =~ '^rxvt-unicode\|xterm\|screen'
    " see ~/.Xresources and ':h xterm-modifier-keys'
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"

    execute "set <PageUp>=\e[5;*~"
    execute "set <PageDown>=\e[6;*~"
    execute "set <Home>=\e[1;*H"
    execute "set <End>=\e[1;*F"

    if &term =~ '^rxvt-unicode\|screen'
        execute "set <xF1>=\e[1;*P"
        execute "set <xF2>=\e[1;*Q"
        execute "set <xF3>=\e[1;*R"
        execute "set <xF4>=\e[1;*S"
    elseif $COLORTERM == 'gnome-terminal'
        execute "set <F1>=\eO1;*P"
        execute "set <F2>=\eO1;*Q"
        execute "set <F3>=\eO1;*R"
        execute "set <F4>=\eO1;*S"
    else " xterm; for some reason t_kf1 etc. get assigned to <xF1> etc.
        execute "set <F1>=\e[1;*P"
        execute "set <F2>=\e[1;*Q"
        execute "set <F3>=\e[1;*R"
        execute "set <F4>=\e[1;*S"
    endif

    execute "set <F5>=\e[15;*~"
    execute "set <F6>=\e[17;*~"
    execute "set <F7>=\e[18;*~"
    execute "set <F8>=\e[19;*~"
    execute "set <F9>=\e[20;*~"
    execute "set <F10>=\e[21;*~"
    execute "set <F11>=\e[23;*~"
    execute "set <F12>=\e[24;*~"

    call s:MapMetaChars()

    call s:MapExtraKeys()
endif

if &term =~ '^rxvt-unicode' || $ORIGTERM =~ '^rxvt-unicode'
    set termbidi
endif

" Change cursor colour or shape in insert mode
" Some ideas from https://github.com/jszakmeister/vim-togglecursor
" tmux will only forward escape sequences to the terminal if surrounded by a DCS sequence
" http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTinkbdoZ8eNR1X2UobLTeww1jFrvfJxTMfKSq-L%2B%40mail.gmail.com&forum_name=tmux-users
let s:terminal = ''
if exists('$TERM_PROGRAM') && $TERM_PROGRAM == 'iTerm.app'
    let s:terminal = 'iterm'
elseif $ORIGTERM =~ '^rxvt-unicode' || $XTERM_VERSION != ''
    let s:terminal = 'xterm'
endif

let s:xterm_normal = "\e]12;yellow\e\\"
let s:xterm_insert = "\e]12;red\e\\"
let s:iterm_normal = "\e]50;CursorShape=0\x7"
let s:iterm_insert = "\e]50;CursorShape=1\x7"

function! s:tmux_escape(code) abort
    let code = substitute(a:code, "\e", "\e\e", 'g')
    return "\ePtmux;" . code . "\e\\"
endfunction

function! s:get_escape(mode) abort
    if s:terminal == ''
        return ''
    endif

    let code = s:{s:terminal}_{a:mode}

    if exists('$TMUX')
        let code = s:tmux_escape(code)
    endif

    return code
endfunction

let &t_SI = s:get_escape('insert')
let &t_EI = s:get_escape('normal')
let &t_te = s:get_escape('normal') . &t_te

" Mappings {{{1

" Buffers/Files/Tabs {{{2

" Fast open a buffer by searching for a name
nnoremap <leader>b :buffers<CR>:buffer<space>

nnoremap <M-Left>  :tabprevious<CR>
nnoremap <M-Right> :tabnext<CR>

" delete buffer and close window
nnoremap   <F8> :bd<cr>
" delete buffer, but keep window
nnoremap <S-F8> :call Bclose()<cr>

" change tabs fast
nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt

nnoremap <C-W>e :enew<CR>

nnoremap <leader>ve :edit ~/.etc/vim/vimrc<CR>
nnoremap <leader>vb :edit ~/.etc/vim/vim/abbrevs.vim<CR>

" Text manipulation {{{2

" Control-Space for omnicomplete
imap <C-Space> <C-X><C-O>

nmap <C-Space> <Plug>(expand_region_expand)
xmap <C-Space> <Plug>(expand_region_expand)

" for popup-menu completion
" http://vim.wikia.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
inoremap <expr> <C-x><C-o> pumvisible() ? '<C-x><C-o>' : '<C-x><C-o><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <C-n>      pumvisible() ? '<C-n>' : '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
" http://vim.wikia.com/wiki/Improve_completion_popup_menu
" inoremap <expr> <Esc>      pumvisible() ? "\<C-E>" : "\<Esc>"
if v:version > 703 || v:version == 703 && has("patch489")
    inoremap <expr> <CR>       pumvisible() ? "\<C-Y>" : "\<C-]>\<CR>"
else
    inoremap <expr> <CR>       pumvisible() ? "\<C-Y>" : "\<CR>"
endif
"inoremap <expr> <Down>     pumvisible() ? "\<C-N>" : "\<Down>"
"inoremap <expr> <Up>       pumvisible() ? "\<C-P>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-P>\<C-N>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-P>\<C-N>"   : "\<PageUp>"

" insert mode completion
" inoremap <C-]> <C-X><C-]>
inoremap <C-F> <C-X><C-F>
"inoremap <C-D> <C-X><C-D>
"inoremap <C-L> <C-X><C-L>

" create undo break points
inoremap <C-U> <C-G>u<C-U>

" Uppercase word
inoremap <M-u> <Esc>gUiwea

" create an undo point after each word
" imap <Space> <Space><C-G>u
"inoremap <Tab>   <Tab><C-G>u
"inoremap <CR>    <CR><C-G>u

" Swap two words
nnoremap <silent> gW :s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR>`'

" have Y behave analogously to D and C rather than to dd and cc (which is
" already done by yy):
nnoremap Y y$

inoremap <C-D> <Del>

nnoremap Q gqip

set pastetoggle=<F3>

nnoremap <S-F2> :call ToggleExpandTab()<CR>

" copy to/from the x cut-buffer
nnoremap <S-Insert> "+gP
xnoremap <S-Insert> "-d"+P
inoremap <S-Insert> <C-R>+
cnoremap <S-Insert> <C-R>+
inoremap <C-Insert> <C-O>"+y
xnoremap <C-Insert> "+y
xnoremap <S-Del>    "+d
inoremap <C-Del>    <C-O>daw

nnoremap <silent> <leader>ga :GNOMEAlignArguments<CR>

" remove trailing whitespace
nnoremap <leader>rt :%s/\s\+$//<CR>
xnoremap <leader>rt  :s/\s\+$//<CR>

" indent for C/C++ programs
nnoremap <leader>i :%!astyle<CR>

"align map for assignments in R scripts
xnoremap <leader>ar :Align <-<CR>

" re-select selection after changing indent
xnoremap > >gv
xnoremap < <gv

inoremap <M-H> <C-d>
inoremap <M-L> <C-t>

" Move current line up or down
inoremap <M-K> <Esc>:<C-U>
            \ let oldpos = getpos('.')<CR>
            \ ddkP
            \ :<C-U>call setpos('.', oldpos)<CR>
            \ gki
inoremap <M-J> <Esc>:<C-U>
            \ let oldpos = getpos('.')<CR>
            \ ddp
            \ :<C-U>call setpos('.', oldpos)<CR>
            \ gji

xmap <Leader>t| <Plug>AM_t|
xmap <Leader>t#   <Plug>AM_t#
xmap <Leader>t,   <Plug>AM_t,
xmap <Leader>t:   <Plug>AM_t:
xmap <Leader>t;   <Plug>AM_t;
xmap <Leader>t<   <Plug>AM_t<
xmap <Leader>t=   <Plug>AM_t=
xmap <Leader>ts,  <Plug>AM_ts,
xmap <Leader>ts:  <Plug>AM_ts:
xmap <Leader>ts;  <Plug>AM_ts;
xmap <Leader>ts<  <Plug>AM_ts<
xmap <Leader>ts=  <Plug>AM_ts=
xmap <Leader>w=   <Plug>AM_w=
xmap <Leader>t?   <Plug>AM_t?
xmap <Leader>t~   <Plug>AM_t~
xmap <Leader>t@   <Plug>AM_t@
xmap <Leader>m=   <Plug>AM_m=
xmap <Leader>tab  <Plug>AM_tab
xmap <Leader>tml  <Plug>AM_tml
xmap <Leader>tsp  <Plug>AM_tsp
xmap <Leader>tsq  <Plug>AM_tsq
xmap <Leader>tt   <Plug>AM_tt

" Ctrl-K comma colon (in Insert mode): UTF-8 single-codepoint ellipsis "..."
" disregard error if (for instance) not in UTF-8
if has("digraphs")
    silent! dig ,:  8230 " HORIZONTAL ELLIPSIS
    silent! dig qi 64259 " LATIN SMALL LIGATURE FFI
    silent! dig ql 64260 " LATIN SMALL LIGATURE FFL
endif

" Moving around {{{2

" make some jumps more intuitive and don't require the '{' to be in the first
" column
nnoremap <silent> [[ ?{<CR>w99[{:nohl<CR>
nnoremap <silent> ][ j0?{<CR>w99[{%/{<CR>:nohl<CR>
nnoremap <silent> ]] ][
xnoremap <silent> [[ ?{<CR>w99[{:<C-U>nohl<CR>gv
xnoremap <silent> ][ j0?{<CR>w99[{%/{<CR>:<C-U>nohl<CR>gv
xnoremap <silent> ]] ][

" move into wrapped lines
nnoremap j gj
nnoremap k gk
"nnoremap $ g$   " conflicts with virtualedit
"nnoremap 0 g0
"nnoremap ^ g^
xnoremap j gj
xnoremap k gk

" emacs-like c-a/c-e movement
inoremap        <c-a> <esc>0i
inoremap <expr> <c-e> pumvisible() ? "\<c-e>" : "\<esc>$a"
inoremap        <c-b> <left>

" move around in insert mode
inoremap <M-h> <Esc>i
inoremap <M-l> <Esc>la
inoremap <M-k> <Esc>gka
inoremap <M-j> <Esc>gja

" display the number of matches of current search pattern
nnoremap g/ :%s/<C-R>=&ignorecase ? '\c' : '\C'<CR><C-R>///gne<CR>

" search for visually selected text
" http://vimcasts.org/episodes/search-for-the-selected-text/
function! s:VSetSearch(cmdtype)
    let temp = @s
    normal! gv"sy
    let @/ = '\V' . substitute(escape(@s, a:cmdtype . '\'), '\n', '\\n', 'g')
    let @s = temp
endfunction

xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

" substitute visual selection
xnoremap & "*y<Esc>:<c-u>%s/<c-r>=substitute(escape(@*, '\/.*$^~[]'), "\n", '\\n', "g")<cr>/

" Display {{{2

" toggle folds
nnoremap <space> :call ToggleFold()<CR>

" toggle showing 'listchars'
nnoremap <F2> :set invlist list?<CR>
imap <F2> <C-O><F2>
xmap <F2> <Esc><F2>gv

nnoremap <silent> zi
    \ :if &foldenable <Bar>
    \     setlocal nofoldenable <Bar>
    \     setlocal foldcolumn=0 <Bar>
    \ else <Bar>
    \     setlocal foldenable <Bar>
    \     setlocal foldcolumn=1 <Bar>
    \ endif<CR>

" remove search highlighting
nnoremap <silent> <C-L> :silent nohl<CR><C-L>

" toggle text wrapping
nnoremap <silent> <leader>w :set invwrap wrap?<CR>

" preview tag definitions
nnoremap <silent> <leader>pw :call PreviewWord(0)<CR>
nnoremap <silent> <leader>pl :call PreviewWord(1)<CR>

" Windows {{{2

" Easier movement between windows
nnoremap <M-h> <C-W>h
nnoremap <M-j> <C-W>j
nnoremap <M-k> <C-W>k
nnoremap <M-l> <C-W>l

" Change window size
nnoremap <M->> <C-W>>
nnoremap <M-<> <C-W><
nnoremap <M-+> <C-W>+
nnoremap <M--> <C-W>-
nnoremap <M-=> <C-W>=

" Command line {{{2

" emacs-like keys in command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>

cnoremap <C-B> <Left>
cnoremap <C-F> <Right>

cnoremap <C-D> <Del>

cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

"cnoremap <Esc><C-B>     <S-Left>
"cnoremap <Esc><C-F>     <S-Right>

" expand %% to current directory
" cabbrev <expr> %% expand('%:~:h')
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Misc {{{2

" for quick macro playback
"nnoremap Q @q

" run current file as a script
nnoremap <leader>e :execute "Shell " . expand("%:p")<CR>

" Switch to current dir
nnoremap <silent> <leader>cd :cd %:p:h<cr>

nnoremap <S-F10> :call GenCscopeAndTags()<CR>

nnoremap <silent> <leader>gk :silent !gitk<cr>

"inoremap  <Esc><Right>

" Modeline {{{1
" vim:tw=78 expandtab comments=\:\" foldmethod=marker foldenable foldcolumn=1
