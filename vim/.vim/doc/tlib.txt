*tlib.txt*  tlib -- A library of vim functions
            Author: Thomas Link, micathom at gmail com


This library provides some utility functions. There isn't much need to 
install it unless another plugin requires you to do so.

Most of the library is included in autoload files. No autocommands are 
created. With the exception of loading ../plugin/02tlib.vim at startup 
the library has no impact on startup time or anything else.

The change-log is included at the bottom of ../plugin/02tlib.vim
(move the cursor over the file name and type gfG)


-----------------------------------------------------------------------
Install~

Edit the vba file and type: >

    :so %

See :help vimball for details. If you have difficulties, please make 
sure, you have the current version of vimball (vimscript #1502) 
installed.


------------------------------------------------------------------------
Contents~

    plugin/02tlib.vim
        :TLet ................................... |:TLet|
        :TScratch ............................... |:TScratch|
        :TVarArg ................................ |:TVarArg|
        :TKeyArg ................................ |:TKeyArg|
        :TBrowseOutput .......................... |:TBrowseOutput|
        g:tlib_pick_last_item ................... |g:tlib_pick_last_item|
        g:tlib_sortprefs_threshold .............. |g:tlib_sortprefs_threshold|
        g:tlib_scratch_pos ...................... |g:tlib_scratch_pos|
        g:tlib_inputlist_pct .................... |g:tlib_inputlist_pct|
        g:tlib_inputlist_width_filename ......... |g:tlib_inputlist_width_filename|
        g:tlib_inputlist_higroup ................ |g:tlib_inputlist_higroup|
        g:tlib_inputlist_livesearch_threshold ... |g:tlib_inputlist_livesearch_threshold|
        g:tlib_inputlist_filename_indicators .... |g:tlib_inputlist_filename_indicators|
        g:tlib_tags_extra ....................... |g:tlib_tags_extra|
        g:tlib_tag_substitute ................... |g:tlib_tag_substitute|
        g:tlib_filename_sep ..................... |g:tlib_filename_sep|
        g:tlib_cache ............................ |g:tlib_cache|
        g:tlib_viewline_position ................ |g:tlib_viewline_position|
        g:tlib_inputlist_and .................... |g:tlib_inputlist_and|
        g:tlib_inputlist_or ..................... |g:tlib_inputlist_or|
        g:tlib_inputlist_not .................... |g:tlib_inputlist_not|
        g:tlib_numeric_chars .................... |g:tlib_numeric_chars|
        g:tlib_keyagents_InputList_s ............ |g:tlib_keyagents_InputList_s|
        g:tlib_scroll_lines ..................... |g:tlib_scroll_lines|
        g:tlib_keyagents_InputList_m ............ |g:tlib_keyagents_InputList_m|
        g:tlib_handlers_EditList ................ |g:tlib_handlers_EditList|
    autoload/tlib/Object.vim
        tlib#Object#New ......................... |tlib#Object#New()|
        prototype.New
        prototype.Inherit
        prototype.Extend
        prototype.IsA
        prototype.IsRelated
        prototype.RespondTo
        prototype.Super
        prototype.Methods
    autoload/tlib/World.vim
        tlib#World#New .......................... |tlib#World#New()|
        prototype.Set_display_format
        prototype.Set_highlight_filename
        prototype.Highlight_filename
        prototype.FormatFilename
        prototype.GetSelectedItems
        prototype.SelectItem
        prototype.FormatArgs
        prototype.GetRx
        prototype.GetRx0
        prototype.GetItem
        prototype.GetListIdx
        prototype.GetBaseIdx
        prototype.GetBaseItem
        prototype.SetBaseItem
        prototype.GetCurrentItem
        prototype.CurrentItem
        prototype.SetFilter
        prototype.Match
        prototype.MatchBaseIdx
        prototype.BuildTable
        prototype.ReduceFilter
        prototype.SetInitialFilter
        prototype.PopFilter
        prototype.FilterIsEmpty
        prototype.DisplayFilter
        prototype.UseScratch
        prototype.CloseScratch
        prototype.UseInputListScratch
        prototype.Reset
        prototype.ResetSelected
        prototype.Retrieve
        prototype.DisplayHelp
        prototype.Resize
        prototype.DisplayList
        prototype.SetOffset
        prototype.DisplayListMark
        prototype.SwitchWindow
        prototype.FollowCursor
        prototype.SetOrigin
        prototype.RestoreOrigin
    autoload/tlib/agent.vim
        tlib#agent#Exit ......................... |tlib#agent#Exit()|
        tlib#agent#CopyItems .................... |tlib#agent#CopyItems()|
        tlib#agent#PageUp ....................... |tlib#agent#PageUp()|
        tlib#agent#PageDown ..................... |tlib#agent#PageDown()|
        tlib#agent#Up ........................... |tlib#agent#Up()|
        tlib#agent#Down ......................... |tlib#agent#Down()|
        tlib#agent#UpN .......................... |tlib#agent#UpN()|
        tlib#agent#DownN ........................ |tlib#agent#DownN()|
        tlib#agent#ShiftLeft .................... |tlib#agent#ShiftLeft()|
        tlib#agent#ShiftRight ................... |tlib#agent#ShiftRight()|
        tlib#agent#Reset ........................ |tlib#agent#Reset()|
        tlib#agent#Input ........................ |tlib#agent#Input()|
        tlib#agent#SuspendToParentWindow ........ |tlib#agent#SuspendToParentWindow()|
        tlib#agent#Suspend ...................... |tlib#agent#Suspend()|
        tlib#agent#Help ......................... |tlib#agent#Help()|
        tlib#agent#OR ........................... |tlib#agent#OR()|
        tlib#agent#AND .......................... |tlib#agent#AND()|
        tlib#agent#ReduceFilter ................. |tlib#agent#ReduceFilter()|
        tlib#agent#PopFilter .................... |tlib#agent#PopFilter()|
        tlib#agent#Debug ........................ |tlib#agent#Debug()|
        tlib#agent#Select ....................... |tlib#agent#Select()|
        tlib#agent#SelectUp ..................... |tlib#agent#SelectUp()|
        tlib#agent#SelectDown ................... |tlib#agent#SelectDown()|
        tlib#agent#SelectAll .................... |tlib#agent#SelectAll()|
        tlib#agent#EditItem ..................... |tlib#agent#EditItem()|
        tlib#agent#NewItem ...................... |tlib#agent#NewItem()|
        tlib#agent#DeleteItems .................. |tlib#agent#DeleteItems()|
        tlib#agent#Cut .......................... |tlib#agent#Cut()|
        tlib#agent#Copy ......................... |tlib#agent#Copy()|
        tlib#agent#Paste ........................ |tlib#agent#Paste()|
        tlib#agent#EditReturnValue .............. |tlib#agent#EditReturnValue()|
        tlib#agent#ViewFile ..................... |tlib#agent#ViewFile()|
        tlib#agent#EditFile ..................... |tlib#agent#EditFile()|
        tlib#agent#EditFileInSplit .............. |tlib#agent#EditFileInSplit()|
        tlib#agent#EditFileInVSplit ............. |tlib#agent#EditFileInVSplit()|
        tlib#agent#EditFileInTab ................ |tlib#agent#EditFileInTab()|
        tlib#agent#ToggleScrollbind ............. |tlib#agent#ToggleScrollbind()|
        tlib#agent#ShowInfo ..................... |tlib#agent#ShowInfo()|
        tlib#agent#PreviewLine .................. |tlib#agent#PreviewLine()|
        tlib#agent#GotoLine ..................... |tlib#agent#GotoLine()|
        tlib#agent#DoAtLine ..................... |tlib#agent#DoAtLine()|
    autoload/tlib/arg.vim
        tlib#arg#Get ............................ |tlib#arg#Get()|
        tlib#arg#Let ............................ |tlib#arg#Let()|
        tlib#arg#Key ............................ |tlib#arg#Key()|
        tlib#arg#StringAsKeyArgs ................ |tlib#arg#StringAsKeyArgs()|
        tlib#arg#Ex ............................. |tlib#arg#Ex()|
    autoload/tlib/buffer.vim
        tlib#buffer#Set ......................... |tlib#buffer#Set()|
        tlib#buffer#Eval ........................ |tlib#buffer#Eval()|
        tlib#buffer#GetList ..................... |tlib#buffer#GetList()|
        tlib#buffer#ViewLine .................... |tlib#buffer#ViewLine()|
        tlib#buffer#HighlightLine ............... |tlib#buffer#HighlightLine()|
        tlib#buffer#DeleteRange ................. |tlib#buffer#DeleteRange()|
        tlib#buffer#ReplaceRange ................ |tlib#buffer#ReplaceRange()|
        tlib#buffer#ScratchStart ................ |tlib#buffer#ScratchStart()|
        tlib#buffer#ScratchEnd .................. |tlib#buffer#ScratchEnd()|
        tlib#buffer#BufDo ....................... |tlib#buffer#BufDo()|
        tlib#buffer#InsertText .................. |tlib#buffer#InsertText()|
        tlib#buffer#InsertText0 ................. |tlib#buffer#InsertText0()|
        tlib#buffer#CurrentByte ................. |tlib#buffer#CurrentByte()|
    autoload/tlib/cache.vim
        tlib#cache#Filename ..................... |tlib#cache#Filename()|
        tlib#cache#Save ......................... |tlib#cache#Save()|
        tlib#cache#Get .......................... |tlib#cache#Get()|
    autoload/tlib/char.vim
        tlib#char#Get ........................... |tlib#char#Get()|
        tlib#char#IsAvailable ................... |tlib#char#IsAvailable()|
        tlib#char#GetWithTimeout ................ |tlib#char#GetWithTimeout()|
    autoload/tlib/cmd.vim
        tlib#cmd#OutputAsList ................... |tlib#cmd#OutputAsList()|
        tlib#cmd#BrowseOutput ................... |tlib#cmd#BrowseOutput()|
        tlib#cmd#UseVertical .................... |tlib#cmd#UseVertical()|
    autoload/tlib/comments.vim
        tlib#comments#Comments .................. |tlib#comments#Comments()|
    autoload/tlib/dir.vim
        tlib#dir#CanonicName .................... |tlib#dir#CanonicName()|
        tlib#dir#PlainName ...................... |tlib#dir#PlainName()|
        tlib#dir#Ensure ......................... |tlib#dir#Ensure()|
        tlib#dir#MyRuntime ...................... |tlib#dir#MyRuntime()|
        tlib#dir#CD ............................. |tlib#dir#CD()|
        tlib#dir#Push ........................... |tlib#dir#Push()|
        tlib#dir#Pop ............................ |tlib#dir#Pop()|
    autoload/tlib/eval.vim
        tlib#eval#FormatValue ................... |tlib#eval#FormatValue()|
    autoload/tlib/file.vim
        tlib#file#Split ......................... |tlib#file#Split()|
        tlib#file#Join .......................... |tlib#file#Join()|
        tlib#file#Relative ...................... |tlib#file#Relative()|
        tlib#file#With .......................... |tlib#file#With()|
    autoload/tlib/hook.vim
        tlib#hook#Run ........................... |tlib#hook#Run()|
    autoload/tlib/input.vim
        tlib#input#List ......................... |tlib#input#List()|
        tlib#input#ListD ........................ |tlib#input#ListD()|
        tlib#input#ListW ........................ |tlib#input#ListW()|
        tlib#input#EditList ..................... |tlib#input#EditList()|
        tlib#input#Resume ....................... |tlib#input#Resume()|
        tlib#input#CommandSelect ................ |tlib#input#CommandSelect()|
        tlib#input#Edit ......................... |tlib#input#Edit()|
    autoload/tlib/list.vim
        tlib#list#Inject ........................ |tlib#list#Inject()|
        tlib#list#Compact ....................... |tlib#list#Compact()|
        tlib#list#Flatten ....................... |tlib#list#Flatten()|
        tlib#list#FindAll ....................... |tlib#list#FindAll()|
        tlib#list#Find .......................... |tlib#list#Find()|
        tlib#list#Any ........................... |tlib#list#Any()|
        tlib#list#All ........................... |tlib#list#All()|
        tlib#list#Remove ........................ |tlib#list#Remove()|
        tlib#list#RemoveAll ..................... |tlib#list#RemoveAll()|
        tlib#list#Zip ........................... |tlib#list#Zip()|
        tlib#list#Uniq .......................... |tlib#list#Uniq()|
    autoload/tlib/progressbar.vim
        tlib#progressbar#Init ................... |tlib#progressbar#Init()|
        tlib#progressbar#Display ................ |tlib#progressbar#Display()|
        tlib#progressbar#Restore ................ |tlib#progressbar#Restore()|
    autoload/tlib/rx.vim
        tlib#rx#Escape .......................... |tlib#rx#Escape()|
    autoload/tlib/scratch.vim
        tlib#scratch#UseScratch ................. |tlib#scratch#UseScratch()|
        tlib#scratch#CloseScratch ............... |tlib#scratch#CloseScratch()|
    autoload/tlib/string.vim
        tlib#string#RemoveBackslashes ........... |tlib#string#RemoveBackslashes()|
        tlib#string#Chomp ....................... |tlib#string#Chomp()|
        tlib#string#Printf1 ..................... |tlib#string#Printf1()|
        tlib#string#TrimLeft .................... |tlib#string#TrimLeft()|
        tlib#string#TrimRight ................... |tlib#string#TrimRight()|
        tlib#string#Strip ....................... |tlib#string#Strip()|
    autoload/tlib/syntax.vim
        tlib#syntax#Collect ..................... |tlib#syntax#Collect()|
        tlib#syntax#Names ....................... |tlib#syntax#Names()|
    autoload/tlib/tab.vim
        tlib#tab#BufMap ......................... |tlib#tab#BufMap()|
        tlib#tab#TabWinNr ....................... |tlib#tab#TabWinNr()|
        tlib#tab#Set ............................ |tlib#tab#Set()|
    autoload/tlib/tag.vim
        tlib#tag#Retrieve ....................... |tlib#tag#Retrieve()|
        tlib#tag#Collect ........................ |tlib#tag#Collect()|
        tlib#tag#Format ......................... |tlib#tag#Format()|
    autoload/tlib/time.vim
        tlib#time#MSecs ......................... |tlib#time#MSecs()|
        tlib#time#Now ........................... |tlib#time#Now()|
        tlib#time#Diff .......................... |tlib#time#Diff()|
        tlib#time#DiffMSecs ..................... |tlib#time#DiffMSecs()|
    autoload/tlib/type.vim
        tlib#type#IsNumber ...................... |tlib#type#IsNumber()|
        tlib#type#IsString ...................... |tlib#type#IsString()|
        tlib#type#IsFuncref ..................... |tlib#type#IsFuncref()|
        tlib#type#IsList ........................ |tlib#type#IsList()|
        tlib#type#IsDictionary .................. |tlib#type#IsDictionary()|
    autoload/tlib/url.vim
        tlib#url#Decode ......................... |tlib#url#Decode()|
        tlib#url#EncodeChar ..................... |tlib#url#EncodeChar()|
        tlib#url#Encode ......................... |tlib#url#Encode()|
    autoload/tlib/var.vim
        tlib#var#Let ............................ |tlib#var#Let()|
        tlib#var#EGet ........................... |tlib#var#EGet()|
        tlib#var#Get ............................ |tlib#var#Get()|
        tlib#var#List ........................... |tlib#var#List()|
    autoload/tlib/win.vim
        tlib#win#Set ............................ |tlib#win#Set()|
        tlib#win#GetLayout ...................... |tlib#win#GetLayout()|
        tlib#win#SetLayout ...................... |tlib#win#SetLayout()|
        tlib#win#Width .......................... |tlib#win#Width()|


------------------------------------------------------------------------
plugin/02tlib.vim~

                                                    *:TLet*
:TLet VAR = VALUE
    Commands
    Set a variable only if it doesn't already exist.
    EXAMPLES: >
      TLet foo = 1
      TLet foo = 2
      echo foo
      => 1
<

                                                    *:TScratch*
:TScratch
    Open a scratch buffer (a buffer without a file).
      TScratch  ... use split window
      TScratch! ... use the whole frame
    This command takes an (inner) dictionnary as optional argument.
    EXAMPLES: >
      TScratch 'scratch': '__FOO__'
      => Open a scratch buffer named __FOO__
<

                                                    *:TVarArg*
:TVarArg VAR1, [VAR2, DEFAULT2] ...
    A convenience wrapper for |tlib#arg#Let|.
    EXAMPLES: >
      function! Foo(...)
          TVarArg ['a', 1], 'b'
          echo 'a='. a
          echo 'b='. b
      endf
<

                                                    *:TKeyArg*
:TKeyArg DICT, VAR1, [VAR2, DEFAULT2] ...
    A convenience wrapper for |tlib#arg#Let|.
    EXAMPLES: >
      function! Foo(keyargs)
          TKeyArg a:keyargs, ['a', 1], 'b'
          echo 'a='. a
          echo 'b='. b
      endf
<

                                                    *:TBrowseOutput*
TBrowseOutput COMMAND
    Every wondered how to effciently browse the output of a command 
    without redirecting it to a file? This command takes a command as 
    argument and presents the output via |tlib#input#List()| so that you 
    can easily search for a keyword (e.g. the name of a variable or 
    function) and the like.
    
    If you press enter, the selected line will be copied to the command 
    line. Press ESC to cancel browsing.
    
    EXAMPLES: >
      TBrowseOutput 20verb TeaseTheCulprit
<

                                                    *g:tlib_pick_last_item*
g:tlib_pick_last_item          (default: 1)
    When 1, automatically select a the last remaining item after applying 
    any filters.

                                                    *g:tlib_sortprefs_threshold*
g:tlib_sortprefs_threshold     (default: 200)
    If a list is bigger than this value, don't try to be smart when 
    selecting an item. Be slightly faster instead.

                                                    *g:tlib_scratch_pos*
g:tlib_scratch_pos             (default: 'botright')
    Scratch window position

                                                    *g:tlib_inputlist_pct*
g:tlib_inputlist_pct           (default: 70)
    Size of the input list window (in percent) from the main size (of &lines).

                                                    *g:tlib_inputlist_width_filename*
g:tlib_inputlist_width_filename (default: '&co / 3')
    Size of filename columns when listing filenames

                                                    *g:tlib_inputlist_higroup*
g:tlib_inputlist_higroup       (default: 'IncSearch')
    The highlight group to use for showing matches in the input list window.

                                                    *g:tlib_inputlist_livesearch_threshold*
g:tlib_inputlist_livesearch_threshold (default: 500)
    If a list contains more items, don't do an incremental "live search", 
    but use |input()| the quere the user for a filter. This is useful on 
    slower machines or with very long lists.

                                                    *g:tlib_inputlist_filename_indicators*
g:tlib_inputlist_filename_indicators (default: 0)
    If true, show some indicators about the status of a filename (eg 
    buflisted(), bufloaded() etc.).
    This is disabled by default because vim checks also for the file on 
    disk when doing this.

                                                    *g:tlib_tags_extra*
g:tlib_tags_extra              (default: '')
    Extra tags for |tlib#tag#Retrieve()| (see there). Can also be buffer-local.

                                                    *g:tlib_tag_substitute*
g:tlib_tag_substitute
    Filter the tag description through |substitute()| for these filetypes. 
    This applies only if the tag cmd field (see |taglist()|) is used.

                                                    *g:tlib_filename_sep*
g:tlib_filename_sep            (default: '/')

                                                    *g:tlib_cache*
g:tlib_cache                   (default: '')
    The cache directory. If empty, use |tlib#dir#MyRuntime|.'/cache'

                                                    *g:tlib_viewline_position*
g:tlib_viewline_position       (default: 'zz')
    Where to display the line when using |tlib#buffer#ViewLine|.
    For possible values for position see |scroll-cursor|.


Keys for |tlib#input#List|~

                                                    *g:tlib_inputlist_and*
g:tlib_inputlist_and           (default: ' ')

                                                    *g:tlib_inputlist_or*
g:tlib_inputlist_or            (default: '|')

                                                    *g:tlib_inputlist_not*
g:tlib_inputlist_not           (default: '-')

                                                    *g:tlib_numeric_chars*
g:tlib_numeric_chars
    When editing a list with |tlib#input#List|, typing these numeric chars 
    (as returned by getchar()) will select an item based on its index, not 
    based on its name. I.e. in the default setting, typing a "4" will 
    select the fourth item, not the item called "4".
    In order to make keys 0-9 filter the items in the list and make 
    <m-[0-9]> select an item by its index, remove the keys 48 to 57 from 
    this dictionary.
    Format: [KEY] = BASE ... the number is calculated as KEY - BASE.

                                                    *g:tlib_keyagents_InputList_s*
g:tlib_keyagents_InputList_s

                                                    *g:tlib_scroll_lines*
g:tlib_scroll_lines            (default: 10)
    Number of items to move when pressing <c-up/down> in the input list window.

                                                    *g:tlib_keyagents_InputList_m*
g:tlib_keyagents_InputList_m

                                                    *g:tlib_handlers_EditList*
g:tlib_handlers_EditList


------------------------------------------------------------------------
autoload/tlib/Object.vim~
Provides a prototype plus some OO-like methods.

                                                    *tlib#Object#New()*
tlib#Object#New(?fields={})
    This function creates a prototype that provides some kind of 
    inheritance mechanism and a way to call parent/super's methods.
    
    The usage demonstrated in the following example works best, when every 
    class/prototype is defined in a file of its own.
    
    The reason for why there is a dedicated constructor function is that 
    this layout facilitates the use of templates and that methods are 
    hidden from the user. Other solutions are possible.
    
    EXAMPLES: >
        let s:prototype = tlib#Object#New({
                    \ '_class': ['FooBar'],
                    \ 'foo': 1, 
                    \ 'bar': 2, 
                    \ })
        " Constructor
        function! FooBar(...)
            let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
            return object
        endf
        function! s:prototype.babble() {
          echo "I think, therefore I am ". (self.foo * self.bar) ." months old."
        }
    
<    This could now be used like this: >
        let myfoo = FooBar({'foo': 3})
        call myfoo.babble()
        => I think, therefore I am 6 months old.
        echo myfoo.IsA('FooBar')
        => 1
        echo myfoo.IsA('object')
        => 1
        echo myfoo.IsA('Foo')
        => 0
        echo myfoo.RespondTo('babble')
        => 1
        echo myfoo.RespondTo('speak')
        => 0
<


prototype.New


prototype.Inherit


prototype.Extend


prototype.IsA


prototype.IsRelated


prototype.RespondTo


prototype.Super


prototype.Methods


------------------------------------------------------------------------
autoload/tlib/World.vim~
A prototype used by |tlib#input#List|.
Inherits from |tlib#Object#New|.

                                                    *tlib#World#New()*
tlib#World#New(...)


prototype.Set_display_format


prototype.Set_highlight_filename


prototype.Highlight_filename


prototype.FormatFilename


prototype.GetSelectedItems


prototype.SelectItem


prototype.FormatArgs


prototype.GetRx


prototype.GetRx0


prototype.GetItem


prototype.GetListIdx


prototype.GetBaseIdx


prototype.GetBaseItem


prototype.SetBaseItem


prototype.GetCurrentItem


prototype.CurrentItem


prototype.SetFilter


prototype.Match


prototype.MatchBaseIdx


prototype.BuildTable


prototype.ReduceFilter


prototype.SetInitialFilter


prototype.PopFilter


prototype.FilterIsEmpty


prototype.DisplayFilter


prototype.UseScratch


prototype.CloseScratch


prototype.UseInputListScratch


prototype.Reset


prototype.ResetSelected


prototype.Retrieve


prototype.DisplayHelp


prototype.Resize


prototype.DisplayList


prototype.SetOffset


prototype.DisplayListMark


prototype.SwitchWindow


prototype.FollowCursor


prototype.SetOrigin


prototype.RestoreOrigin


------------------------------------------------------------------------
autoload/tlib/agent.vim~
Various agents for use as key handlers in tlib#input#List()

                                                    *tlib#agent#Exit()*
tlib#agent#Exit(world, selected)

                                                    *tlib#agent#CopyItems()*
tlib#agent#CopyItems(world, selected)

                                                    *tlib#agent#PageUp()*
tlib#agent#PageUp(world, selected)

                                                    *tlib#agent#PageDown()*
tlib#agent#PageDown(world, selected)

                                                    *tlib#agent#Up()*
tlib#agent#Up(world, selected, ...)

                                                    *tlib#agent#Down()*
tlib#agent#Down(world, selected, ...)

                                                    *tlib#agent#UpN()*
tlib#agent#UpN(world, selected)

                                                    *tlib#agent#DownN()*
tlib#agent#DownN(world, selected)

                                                    *tlib#agent#ShiftLeft()*
tlib#agent#ShiftLeft(world, selected)

                                                    *tlib#agent#ShiftRight()*
tlib#agent#ShiftRight(world, selected)

                                                    *tlib#agent#Reset()*
tlib#agent#Reset(world, selected)

                                                    *tlib#agent#Input()*
tlib#agent#Input(world, selected)

                                                    *tlib#agent#SuspendToParentWindow()*
tlib#agent#SuspendToParentWindow(world, selected)
    Suspend (see |tlib#agent#Suspend|) the input loop and jump back to the 
    original position in the parent window.

                                                    *tlib#agent#Suspend()*
tlib#agent#Suspend(world, selected)
    Suspend lets you temporarily leave the input loop of 
    |tlib#input#List|. You can resume editing the list by pressing <c-z>, 
    <m-z>. <cr>, <space>, or <LeftMouse> in the suspended window.

                                                    *tlib#agent#Help()*
tlib#agent#Help(world, selected)

                                                    *tlib#agent#OR()*
tlib#agent#OR(world, selected)

                                                    *tlib#agent#AND()*
tlib#agent#AND(world, selected)

                                                    *tlib#agent#ReduceFilter()*
tlib#agent#ReduceFilter(world, selected)

                                                    *tlib#agent#PopFilter()*
tlib#agent#PopFilter(world, selected)

                                                    *tlib#agent#Debug()*
tlib#agent#Debug(world, selected)

                                                    *tlib#agent#Select()*
tlib#agent#Select(world, selected)

                                                    *tlib#agent#SelectUp()*
tlib#agent#SelectUp(world, selected)

                                                    *tlib#agent#SelectDown()*
tlib#agent#SelectDown(world, selected)

                                                    *tlib#agent#SelectAll()*
tlib#agent#SelectAll(world, selected)

                                                    *tlib#agent#EditItem()*
tlib#agent#EditItem(world, selected)

                                                    *tlib#agent#NewItem()*
tlib#agent#NewItem(world, selected)

                                                    *tlib#agent#DeleteItems()*
tlib#agent#DeleteItems(world, selected)

                                                    *tlib#agent#Cut()*
tlib#agent#Cut(world, selected)

                                                    *tlib#agent#Copy()*
tlib#agent#Copy(world, selected)

                                                    *tlib#agent#Paste()*
tlib#agent#Paste(world, selected)

                                                    *tlib#agent#EditReturnValue()*
tlib#agent#EditReturnValue(world, rv)

                                                    *tlib#agent#ViewFile()*
tlib#agent#ViewFile(world, selected)

                                                    *tlib#agent#EditFile()*
tlib#agent#EditFile(world, selected)

                                                    *tlib#agent#EditFileInSplit()*
tlib#agent#EditFileInSplit(world, selected)

                                                    *tlib#agent#EditFileInVSplit()*
tlib#agent#EditFileInVSplit(world, selected)

                                                    *tlib#agent#EditFileInTab()*
tlib#agent#EditFileInTab(world, selected)

                                                    *tlib#agent#ToggleScrollbind()*
tlib#agent#ToggleScrollbind(world, selected)

                                                    *tlib#agent#ShowInfo()*
tlib#agent#ShowInfo(world, selected)

                                                    *tlib#agent#PreviewLine()*
tlib#agent#PreviewLine(world, selected)

                                                    *tlib#agent#GotoLine()*
tlib#agent#GotoLine(world, selected)
    If not called from the scratch, we assume/guess that we don't have to 
    suspend the input-evaluation loop.

                                                    *tlib#agent#DoAtLine()*
tlib#agent#DoAtLine(world, selected)


------------------------------------------------------------------------
autoload/tlib/arg.vim~

                                                    *tlib#arg#Get()*
tlib#arg#Get(n, var, ?default="", ?test='')
    Set a positional argument from a variable argument list.
    See tlib#string#RemoveBackslashes() for an example.

                                                    *tlib#arg#Let()*
tlib#arg#Let(list, ?default='')
    Set a positional arguments from a variable argument list.
    See tlib#input#List() for an example.

                                                    *tlib#arg#Key()*
tlib#arg#Key(dict, list, ?default='')
    See |:TKeyArg|.

                                                    *tlib#arg#StringAsKeyArgs()*
tlib#arg#StringAsKeyArgs(string, ?keys=[], ?evaluate=0)

                                                    *tlib#arg#Ex()*
tlib#arg#Ex(arg, ?chars='%# ')
    Escape some characters in a string.
    
    EXAMPLES: >
      exec 'edit '. tlib#arg#Ex('foo%#bar.txt')
<


------------------------------------------------------------------------
autoload/tlib/buffer.vim~

                                                    *tlib#buffer#Set()*
tlib#buffer#Set(buffer)
    Set the buffer to buffer and return a command as string that can be 
    evaluated by |:execute| in order to restore the original view.

                                                    *tlib#buffer#Eval()*
tlib#buffer#Eval(buffer, code)
    Evaluate CODE in BUFFER.
    
    EXAMPLES: >
      call tlib#buffer#Eval('foo.txt', 'echo b:bar')
<

                                                    *tlib#buffer#GetList()*
tlib#buffer#GetList(?show_hidden=0, ?show_number=0)

                                                    *tlib#buffer#ViewLine()*
tlib#buffer#ViewLine(line, ?position='z')
    line is either a number or a string that begins with a number.
    For possible values for position see |scroll-cursor|.
    See also |g:tlib_viewline_position|.

                                                    *tlib#buffer#HighlightLine()*
tlib#buffer#HighlightLine(line)

                                                    *tlib#buffer#DeleteRange()*
tlib#buffer#DeleteRange(line1, line2)
    Delete the lines in the current buffer. Wrapper for |:delete|.

                                                    *tlib#buffer#ReplaceRange()*
tlib#buffer#ReplaceRange(line1, line2, lines)
    Replace a range of lines.

                                                    *tlib#buffer#ScratchStart()*
tlib#buffer#ScratchStart()
    Initialize some scratch area at the bottom of the current buffer.

                                                    *tlib#buffer#ScratchEnd()*
tlib#buffer#ScratchEnd()
    Remove the in-buffer scratch area.

                                                    *tlib#buffer#BufDo()*
tlib#buffer#BufDo(exec)
    Run exec on all buffers via bufdo and return to the original buffer.

                                                    *tlib#buffer#InsertText()*
tlib#buffer#InsertText(text, keyargs)
    Keyargs:
      'shift': 0|N
      'col': col('.')|N
      'lineno': line('.')|N
      'indent': 0|1
      'pos': 'e'|'s' ... Where to locate the cursor (somewhat like s and e in {offset})
    Insert text (a string) in the buffer.

                                                    *tlib#buffer#InsertText0()*
tlib#buffer#InsertText0(text, ...)

                                                    *tlib#buffer#CurrentByte()*
tlib#buffer#CurrentByte()


------------------------------------------------------------------------
autoload/tlib/cache.vim~

                                                    *tlib#cache#Filename()*
tlib#cache#Filename(type, ?file=%, ?mkdir=0)

                                                    *tlib#cache#Save()*
tlib#cache#Save(cfile, dictionary)

                                                    *tlib#cache#Get()*
tlib#cache#Get(cfile)


------------------------------------------------------------------------
autoload/tlib/char.vim~

                                                    *tlib#char#Get()*
tlib#char#Get(?timeout=0)
    Get a character.
    
    EXAMPLES: >
      echo tlib#char#Get()
      echo tlib#char#Get(5)
<

                                                    *tlib#char#IsAvailable()*
tlib#char#IsAvailable()

                                                    *tlib#char#GetWithTimeout()*
tlib#char#GetWithTimeout(timeout, ...)


------------------------------------------------------------------------
autoload/tlib/cmd.vim~

                                                    *tlib#cmd#OutputAsList()*
tlib#cmd#OutputAsList(command)

                                                    *tlib#cmd#BrowseOutput()*
tlib#cmd#BrowseOutput(command)
    See |:TBrowseOutput|.

                                                    *tlib#cmd#UseVertical()*
tlib#cmd#UseVertical(?rx='')
    Look at the history whether the command was called with vertical. If 
    an rx is provided check first if the last entry in the history matches 
    this rx.


------------------------------------------------------------------------
autoload/tlib/comments.vim~

                                                    *tlib#comments#Comments()*
tlib#comments#Comments(...)
    function! tlib#comments#Comments(?rx='')


------------------------------------------------------------------------
autoload/tlib/dir.vim~

                                                    *tlib#dir#CanonicName()*
tlib#dir#CanonicName(dirname)
    EXAMPLES: >
      tlib#dir#CanonicName('foo/bar')
      => 'foo/bar/'
<

                                                    *tlib#dir#PlainName()*
tlib#dir#PlainName(dirname)
    EXAMPLES: >
      tlib#dir#PlainName('foo/bar/')
      => 'foo/bar'
<

                                                    *tlib#dir#Ensure()*
tlib#dir#Ensure(dir)
    Create a directory if it doesn't already exist.

                                                    *tlib#dir#MyRuntime()*
tlib#dir#MyRuntime()
    Return the first directory in &rtp.

                                                    *tlib#dir#CD()*
tlib#dir#CD(dir, ?locally=0)

                                                    *tlib#dir#Push()*
tlib#dir#Push(dir, ?locally=0)

                                                    *tlib#dir#Pop()*
tlib#dir#Pop()


------------------------------------------------------------------------
autoload/tlib/eval.vim~

                                                    *tlib#eval#FormatValue()*
tlib#eval#FormatValue(value, ...)


------------------------------------------------------------------------
autoload/tlib/file.vim~

                                                    *tlib#file#Split()*
tlib#file#Split(filename)
    EXAMPLES: >
      tlib#file#Split('foo/bar/filename.txt')
      => ['foo', 'bar', 'filename.txt']
<

                                                    *tlib#file#Join()*
tlib#file#Join(filename_parts)
    EXAMPLES: >
      tlib#file#Join(['foo', 'bar', 'filename.txt'])
      => 'foo/bar/filename.txt'
<

                                                    *tlib#file#Relative()*
tlib#file#Relative(filename, basedir)
    EXAMPLES: >
      tlib#file#Relative('foo/bar/filename.txt', 'foo')
      => 'bar/filename.txt'
<

                                                    *tlib#file#With()*
tlib#file#With(fcmd, bcmd, files, ?world={})


------------------------------------------------------------------------
autoload/tlib/hook.vim~

                                                    *tlib#hook#Run()*
tlib#hook#Run(hook, ?dict={})
    Execute dict[hook], w:{hook}, b:{hook}, or g:{hook} if existent.


------------------------------------------------------------------------
autoload/tlib/input.vim~
Input-related, select from a list etc.

                                                    *tlib#input#List()*
tlib#input#List(type. ?query='', ?list=[], ?handlers=[], ?default="", ?timeout=0)
    Select a single or multiple items from a list. Return either the list 
    of selected elements or its indexes.
    
    By default, typing numbers will select an item by its index. See 
    |g:tlib_numeric_chars| to find out how to change this.
    
    The item is automatically selected if the numbers typed equals the 
    number of digits of the list length. I.e. if a list contains 20 items, 
    typing 1 will first highlight item 1 but it won't select/use it 
    because 1 is an ambiguous input in this context. If you press enter, 
    the first item will be selected. If you press another digit (e.g. 0), 
    item 10 will be selected. Another way to select item 1 would be to 
    type 01. If the list contains only 9 items, typing 1 would select the 
    first item right away.
    
    type can be:
        s  ... Return one selected element
        si ... Return the index of the selected element
        m  ... Return a list of selcted elements
        mi ... Return a list of indexes
    
    EXAMPLES: >
      echo tlib#input#List('s', 'Select one item', [100,200,300])
      echo tlib#input#List('si', 'Select one item', [100,200,300])
      echo tlib#input#List('m', 'Select one or more item(s)', [100,200,300])
      echo tlib#input#List('mi', 'Select one or more item(s)', [100,200,300])
<

                                                    *tlib#input#ListD()*
tlib#input#ListD(dict)
    A wrapper for |tlib#input#ListW()| that builds |tlib#World#New| from 
    dict.

                                                    *tlib#input#ListW()*
tlib#input#ListW(world, ?command='')
    The second argument, command is meant for internal use only.
    The same as |tlib#input#List| but the arguments are packed into world 
    (an instance of tlib#World as returned by |tlib#World#New|).

                                                    *tlib#input#EditList()*
tlib#input#EditList(query, list, ?timeout=0)
    Edit a list.
    
    EXAMPLES: >
      echo tlib#input#EditList('Edit:', [100,200,300])
<

                                                    *tlib#input#Resume()*
tlib#input#Resume(name)

                                                    *tlib#input#CommandSelect()*
tlib#input#CommandSelect(command, ?keyargs={})
    Take a command, view the output, and let the user select an item from 
    its output.
    
    EXAMPLE: >
        command! TMarks exec 'norm! `'. matchstr(tlib#input#CommandSelect('marks'), '^ \+\zs.')
        command! TAbbrevs exec 'norm i'. matchstr(tlib#input#CommandSelect('abbrev'), '^\S\+\s\+\zs\S\+')
<

                                                    *tlib#input#Edit()*
tlib#input#Edit(name, value, callback, ?cb_args=[])
    
    Edit a value (asynchronously) in a scratch buffer. Use name for 
    identification. Call callback when done (or on cancel).
    In the scratch buffer:
    Press <c-s> or <c-w><cr> to enter the new value, <c-w>c to cancel 
    editing.
    EXAMPLES: >
      fun! FooContinue(success, text)
          if a:success
              let b:var = a:text
          endif
      endf
      call tlib#input#Edit('foo', b:var, 'FooContinue')
<


------------------------------------------------------------------------
autoload/tlib/list.vim~

                                                    *tlib#list#Inject()*
tlib#list#Inject(list, initial_value, funcref)
    EXAMPLES: >
      echo tlib#list#Inject([1,2,3], 0, function('Add')
      => 6
<

                                                    *tlib#list#Compact()*
tlib#list#Compact(list)
    EXAMPLES: >
      tlib#list#Compact([0,1,2,3,[], {}, ""])
      => [1,2,3]
<

                                                    *tlib#list#Flatten()*
tlib#list#Flatten(list)
    EXAMPLES: >
      tlib#list#Flatten([0,[1,2,[3,""]]])
      => [0,1,2,3,""]
<

                                                    *tlib#list#FindAll()*
tlib#list#FindAll(list, filter, ?process_expr="")
    Basically the same as filter()
    
    EXAMPLES: >
      tlib#list#FindAll([1,2,3], 'v:val >= 2')
      => [2, 3]
<

                                                    *tlib#list#Find()*
tlib#list#Find(list, filter, ?default="", ?process_expr="")
    
    EXAMPLES: >
      tlib#list#Find([1,2,3], 'v:val >= 2')
      => 2
<

                                                    *tlib#list#Any()*
tlib#list#Any(list, expr)
    EXAMPLES: >
      tlib#list#Any([1,2,3], 'v:val >= 2')
      => 1
<

                                                    *tlib#list#All()*
tlib#list#All(list, expr)
    EXAMPLES: >
      tlib#list#All([1,2,3], 'v:val >= 2')
      => 0
<

                                                    *tlib#list#Remove()*
tlib#list#Remove(list, element)
    EXAMPLES: >
      tlib#list#Remove([1,2,1,2], 2)
      => [1,1,2]
<

                                                    *tlib#list#RemoveAll()*
tlib#list#RemoveAll(list, element)
    EXAMPLES: >
      tlib#list#RemoveAll([1,2,1,2], 2)
      => [1,1]
<

                                                    *tlib#list#Zip()*
tlib#list#Zip(lists, ?default='')
    EXAMPLES: >
      tlib#list#Zip([[1,2,3], [4,5,6]])
      => [[1,4], [2,5], [3,6]]
<

                                                    *tlib#list#Uniq()*
tlib#list#Uniq(list, ...)


------------------------------------------------------------------------
autoload/tlib/progressbar.vim~

                                                    *tlib#progressbar#Init()*
tlib#progressbar#Init(max, ...)
    EXAMPLE: >
        call tlib#progressbar#Init(20)
        try
            for i in range(20)
                call tlib#progressbar#Display(i)
                call DoSomethingThatTakesSomeTime(i)
            endfor
        finally
            call tlib#progressbar#Restore()
        endtry
<

                                                    *tlib#progressbar#Display()*
tlib#progressbar#Display(value, ...)

                                                    *tlib#progressbar#Restore()*
tlib#progressbar#Restore()


------------------------------------------------------------------------
autoload/tlib/rx.vim~

                                                    *tlib#rx#Escape()*
tlib#rx#Escape(text, ?magic='m')
    magic can be one of: m, M, v, V
    See :help 'magic'


------------------------------------------------------------------------
autoload/tlib/scratch.vim~

                                                    *tlib#scratch#UseScratch()*
tlib#scratch#UseScratch(?keyargs={})
    Display a scratch buffer (a buffer with no file). See :TScratch for an 
    example.
    Return the scratch's buffer number.

                                                    *tlib#scratch#CloseScratch()*
tlib#scratch#CloseScratch(keyargs, ...)
    Close a scratch buffer as defined in keyargs (usually a World).


------------------------------------------------------------------------
autoload/tlib/string.vim~

                                                    *tlib#string#RemoveBackslashes()*
tlib#string#RemoveBackslashes(text, ?chars=' ')
    Remove backslashes from text (but only in front of the characters in 
    chars).

                                                    *tlib#string#Chomp()*
tlib#string#Chomp(string)

                                                    *tlib#string#Printf1()*
tlib#string#Printf1(format, string)
    This function deviates from |printf()| in certain ways.
    Additional items:
        %{rx}      ... insert escaped regexp
        %{fuzzyrx} ... insert typo-tolerant regexp

                                                    *tlib#string#TrimLeft()*
tlib#string#TrimLeft(string)

                                                    *tlib#string#TrimRight()*
tlib#string#TrimRight(string)

                                                    *tlib#string#Strip()*
tlib#string#Strip(string)


------------------------------------------------------------------------
autoload/tlib/syntax.vim~

                                                    *tlib#syntax#Collect()*
tlib#syntax#Collect()

                                                    *tlib#syntax#Names()*
tlib#syntax#Names(?rx='')


------------------------------------------------------------------------
autoload/tlib/tab.vim~

                                                    *tlib#tab#BufMap()*
tlib#tab#BufMap()
    Return a dictionary of bufnumbers => [[tabpage, winnr] ...]

                                                    *tlib#tab#TabWinNr()*
tlib#tab#TabWinNr(buffer)
    Find a buffer's window at some tab page.

                                                    *tlib#tab#Set()*
tlib#tab#Set(tabnr)


------------------------------------------------------------------------
autoload/tlib/tag.vim~

                                                    *tlib#tag#Retrieve()*
tlib#tag#Retrieve(rx, ?extra_tags=0)
    Get all tags matching rx. Basically, this function simply calls 
    |taglist()|, but when extra_tags is true, the list of the tag files 
    (see 'tags') is temporarily expanded with |g:tlib_tags_extra|.
    
    Example use:
    If want to include tags for, eg, JDK, normal tags use can become slow. 
    You could proceed as follows:
        1. Create a tags file for the JDK sources. When creating the tags 
        file, make sure to include inheritance information and the like 
        (command-line options like --fields=+iaSm --extra=+q should be ok).
        In this example, we want tags only for public methods (there are 
        most likely better ways to do this): >
             ctags -R --fields=+iaSm --extra=+q ${JAVA_HOME}/src
             head -n 6 tags > tags0
             grep access:public tags >> tags0
<       2. Say 'tags' included project specific tags files. In 
         ~/vimfiles/after/ftplugin/java.vim insert: >
             let b:tlib_tags_extra = $JAVA_HOME .'/tags0'
<       3. When this function is invoked as >
             echo tlib#tag#Retrieve('print')
<       It will return only project-local tags. If it is invoked as >
             echo tlib#tag#Retrieve('print', 1)
<       tags from the JDK will be included.

                                                    *tlib#tag#Collect()*
tlib#tag#Collect(constraints, ?use_extra=1, ?match_front=1)
    Retrieve tags that meet the the constraints (a dictionnary of fields and 
    regexp, with the exception of the kind field that is a list of chars). 
    For the use of the optional use_extra argument see 
    |tlib#tag#Retrieve()|.

                                                    *tlib#tag#Format()*
tlib#tag#Format(tag)


------------------------------------------------------------------------
autoload/tlib/time.vim~

                                                    *tlib#time#MSecs()*
tlib#time#MSecs()

                                                    *tlib#time#Now()*
tlib#time#Now()

                                                    *tlib#time#Diff()*
tlib#time#Diff(a, b, ...)

                                                    *tlib#time#DiffMSecs()*
tlib#time#DiffMSecs(a, b, ...)


------------------------------------------------------------------------
autoload/tlib/type.vim~

                                                    *tlib#type#IsNumber()*
tlib#type#IsNumber(expr)

                                                    *tlib#type#IsString()*
tlib#type#IsString(expr)

                                                    *tlib#type#IsFuncref()*
tlib#type#IsFuncref(expr)

                                                    *tlib#type#IsList()*
tlib#type#IsList(expr)

                                                    *tlib#type#IsDictionary()*
tlib#type#IsDictionary(expr)


------------------------------------------------------------------------
autoload/tlib/url.vim~

                                                    *tlib#url#Decode()*
tlib#url#Decode(url)
    Decode an encoded URL.

                                                    *tlib#url#EncodeChar()*
tlib#url#EncodeChar(char)
    Encode a single character.

                                                    *tlib#url#Encode()*
tlib#url#Encode(url, ...)
    Encode an url.


------------------------------------------------------------------------
autoload/tlib/var.vim~

                                                    *tlib#var#Let()*
tlib#var#Let(name, val)
    Define a variable called NAME if yet undefined.
    You can also use the :TLLet command.
    
    EXAMPLES: >
      exec tlib#var#Let('g:foo', 1)
      TLet g:foo = 1
<

                                                    *tlib#var#EGet()*
tlib#var#EGet(var, namespace, ?default='')
    Retrieve a variable by searching several namespaces.
    
    EXAMPLES: >
      let g:foo = 1
      let b:foo = 2
      let w:foo = 3
      echo eval(tlib#var#EGet('foo', 'vg'))  => 1
      echo eval(tlib#var#EGet('foo', 'bg'))  => 2
      echo eval(tlib#var#EGet('foo', 'wbg')) => 3
<

                                                    *tlib#var#Get()*
tlib#var#Get(var, namespace, ?default='')
    Retrieve a variable by searching several namespaces.
    
    EXAMPLES: >
      let g:foo = 1
      let b:foo = 2
      let w:foo = 3
      echo tlib#var#Get('foo', 'vg')  => 1
      echo tlib#var#Get('foo', 'bg')  => 2
      echo tlib#var#Get('foo', 'wbg') => 3
<

                                                    *tlib#var#List()*
tlib#var#List(rx, ?prefix='')
    Get a list of variables matching rx.
    EXAMPLE:
      echo tlib#var#List('tlib_', 'g:')


------------------------------------------------------------------------
autoload/tlib/win.vim~

                                                    *tlib#win#Set()*
tlib#win#Set(winnr)
    Return vim code to jump back to the original window.

                                                    *tlib#win#GetLayout()*
tlib#win#GetLayout(?save_view=0)

                                                    *tlib#win#SetLayout()*
tlib#win#SetLayout(layout)

                                                    *tlib#win#Width()*
tlib#win#Width(wnr)


